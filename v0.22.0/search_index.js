var documenterSearchIndex = {"docs":
[{"location":"geometries/polytopes.html#Polytopes","page":"Polytopes","title":"Polytopes","text":"","category":"section"},{"location":"geometries/polytopes.html","page":"Polytopes","title":"Polytopes","text":"Polytope\nPolygon\nPolyhedron\nSegment\nNgon\nChain\nPolyArea\nTetrahedron\nPyramid\nHexahedron","category":"page"},{"location":"geometries/polytopes.html#Meshes.Polytope","page":"Polytopes","title":"Meshes.Polytope","text":"Polytope{K,Dim,T}\n\nWe say that a geometry is a K-polytope when it is a collection of \"flat\" sides that constitue a K-dimensional subspace. They are called polygon and polyhedron respectively for 2D (K=2) and 3D (K=3) subspaces, embedded in a Dim-dimensional space. The parameter K is also known as the rank or parametric dimension of the polytope: https://en.wikipedia.org/wiki/Abstract_polytope.\n\nThe term polytope expresses a particular combinatorial structure. A polyhedron, for example, can be decomposed into faces. Each face can then be decomposed into edges, and edges into vertices. Some conventions act as a mapping between vertices and higher dimensional features (edges, faces, cells...), removing the need to store all features.\n\nAdditionally, the following property must hold in order for a geometry to be considered a polytope: the boundary of a (K+1)-polytope is a collection of K-polytopes, which may have (K-1)-polytopes in common. See https://en.wikipedia.org/wiki/Polytope.\n\nNotes\n\nType aliases are Polygon, Polyhedron.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes.html#Meshes.Polygon","page":"Polytopes","title":"Meshes.Polygon","text":"Polygon{Dim,T}\n\nA polygon is a 2-polytope, i.e. a polytope with parametric dimension 2.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes.html#Meshes.Polyhedron","page":"Polytopes","title":"Meshes.Polyhedron","text":"Polyhedron{Dim,T}\n\nA polyhedron is a 3-polytope, i.e. a polytope with parametric dimension 3.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes.html#Meshes.Segment","page":"Polytopes","title":"Meshes.Segment","text":"Segment(p1, p2)\n\nAn oriented line segment with end points p1, p2. The segment can be called as s(t) with t between 0 and 1 to interpolate linearly between its endpoints.\n\nSee also Line.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes.html#Meshes.Ngon","page":"Polytopes","title":"Meshes.Ngon","text":"Ngon(p1, p2, ..., pN)\n\nA N-gon is a polygon with N vertices p1, p2, ..., pN oriented counter-clockwise (CCW). In this case the number of vertices is fixed and known at compile time. Examples of N-gon are Triangle (N=3), Quadrangle (N=4), Pentagon (N=5), etc.\n\nNotes\n\nAlthough the number of vertices N is known at compile time, we use abstract vectors to store the list of vertices. This design allows constructing N-gon from views of global vectors without expensive memory allocations.\nType aliases are Triangle, Quadrangle, Pentagon, Hexagon, Heptagon, Octagon, Nonagon, Decagon.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes.html#Meshes.Chain","page":"Polytopes","title":"Meshes.Chain","text":"Chain(p1, p2, ..., pn)\n\nA polygonal chain from a sequence of points p1, p2, ..., pn. See https://en.wikipedia.org/wiki/Polygonal_chain.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes.html#Meshes.PolyArea","page":"Polytopes","title":"Meshes.PolyArea","text":"PolyArea(outer, [inner1, inner2, ..., innerk]; fix=true)\n\nA polygonal area with outer chain, and optional inner chains inner1, inner2, ..., innerk.\n\nChains can be a vector of Point or a vector of tuples with coordinates for convenience.\n\nThe option fix tries to correct issues with polygons in the real world, including issues with:\n\norientation - Most algorithms assume that the outer ring is oriented counter-clockwise (CCW) and that all inner rings are oriented clockwise (CW).\ndegeneracy - Sometimes data is shared with degenerate rings (i.e. only 2 vertices).\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes.html#Meshes.Tetrahedron","page":"Polytopes","title":"Meshes.Tetrahedron","text":"Tetrahedron(p1, p2, p3, p4)\n\nA tetrahedron with points p1, p2, p3, p4.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes.html#Meshes.Pyramid","page":"Polytopes","title":"Meshes.Pyramid","text":"Pyramid(p1, p2, p3, p4, p5)\n\nA pyramid with points p1, p2, p3, p4, p5.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes.html#Meshes.Hexahedron","page":"Polytopes","title":"Meshes.Hexahedron","text":"Hexahedron(p1, p2, ..., p8)\n\nA hexahedron with points p1, p2, ..., p8.\n\n\n\n\n\n","category":"type"},{"location":"links.html#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"links.html","page":"Index","title":"Index","text":"Below is the list of types and functions mentioned in the documentation.","category":"page"},{"location":"links.html#Types","page":"Index","title":"Types","text":"","category":"section"},{"location":"links.html","page":"Index","title":"Index","text":"Order = [:type]","category":"page"},{"location":"links.html#Functions","page":"Index","title":"Functions","text":"","category":"section"},{"location":"links.html","page":"Index","title":"Index","text":"Order = [:function]","category":"page"},{"location":"visualization.html#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"All geometries and meshes can be visualized with MeshViz.jl. The package exports a single viz command that can be used to add objects to the scene with a consistent set of attributes.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"viz","category":"page"},{"location":"visualization.html#MeshViz.viz","page":"Visualization","title":"MeshViz.viz","text":"viz(object)\n\nVisualize Meshes.jl object with various options:\n\nsize          - size of points in point set\ncolor         - color of geometries or points\ncolormap      - colormap used for colors\nboundarycolor - color of the boundary (e.g. segments)\nfacetcolor    - color of the facets (e.g. edges)\nshowboundary  - tells whether or not to show the boundary\nshowfacets    - tells whether or not to show the facets\nvariable      - informs which variable to visualize\ndecimation    - decimation tolerance for polygons\n\nThe option color can be a single scalar or a vector of scalars. For meshes, the length of the vector of colors determines if the colors should be assigned to vertices or elements.\n\nExamples\n\n# vertex coloring (i.e. linear interpolation)\nviz(mesh, color = 1:nvertices(mesh))\n\n# element coloring (i.e. discrete colors)\nviz(mesh, color = 1:nelements(mesh))\n\n\n\n\n\n","category":"function"},{"location":"points.html#Points","page":"Points","title":"Points","text":"","category":"section"},{"location":"points.html","page":"Points","title":"Points","text":"Point\nembeddim(::Point)\ncoordtype(::Point)\ncoordinates(::Point)\n-(::Point, ::Point)\n+(::Point, ::Vec)\n-(::Point, ::Vec)\nisapprox(::Point, ::Point)","category":"page"},{"location":"points.html#Meshes.Point","page":"Points","title":"Meshes.Point","text":"Point{Dim,T}\n\nA point in Dim-dimensional space with coordinates of type T.\n\nThe coordinates of the point are given with respect to the canonical Euclidean basis, and Integer coordinates are converted to Float64.\n\nExamples\n\n# 2D points\nA = Point(0.0, 1.0) # double precision as expected\nB = Point(0f0, 1f0) # single precision as expected\nC = Point(0, 0) # Integer is converted to Float64 by design\nD = Point2(0, 1) # explicitly ask for double precision\nE = Point2f(0, 1) # explicitly ask for single precision\n\n# 3D points\nF = Point(1.0, 2.0, 3.0) # double precision as expected\nG = Point(1f0, 2f0, 3f0) # single precision as expected\nH = Point(1, 2, 3) # Integer is converted to Float64 by design\nI = Point3(1, 2, 3) # explicitly ask for double precision\nJ = Point3f(1, 2, 3) # explicitly ask for single precision\n\nNotes\n\nType aliases are Point1, Point2, Point3, Point1f, Point2f, Point3f\nInteger coordinates are not supported because most geometric processing algorithms assume a continuous space. The conversion to Float64 avoids InexactError and other unexpected results.\n\n\n\n\n\n","category":"type"},{"location":"points.html#Meshes.embeddim-Tuple{Point}","page":"Points","title":"Meshes.embeddim","text":"embeddim(point)\n\nReturn the number of dimensions of the space where the point is embedded.\n\n\n\n\n\nembeddim(domain)\n\nReturn the number of dimensions of the space where the domain is embedded.\n\n\n\n\n\nembeddim(geometry)\n\nReturn the number of dimensions of the space where the geometry is embedded.\n\n\n\n\n\n","category":"method"},{"location":"points.html#Meshes.coordtype-Tuple{Point}","page":"Points","title":"Meshes.coordtype","text":"coordtype(point)\n\nReturn the machine type of each coordinate used to describe the point.\n\n\n\n\n\ncoordtype(domain)\n\nReturn the machine type of each coordinate used to describe the domain.\n\n\n\n\n\ncoordtype(geometry)\n\nReturn the machine type of each coordinate used to describe the geometry.\n\n\n\n\n\n","category":"method"},{"location":"points.html#Meshes.coordinates-Tuple{Point}","page":"Points","title":"Meshes.coordinates","text":"coordinates(A::Point)\n\nReturn the coordinates of the point with respect to the canonical Euclidean basis.\n\n\n\n\n\n","category":"method"},{"location":"points.html#Base.:--Tuple{Point, Point}","page":"Points","title":"Base.:-","text":"-(A::Point, B::Point)\n\nReturn the Vec associated with the direction from point A to point B.\n\n\n\n\n\n","category":"method"},{"location":"points.html#Base.:+-Tuple{Point, StaticArrays.SVector}","page":"Points","title":"Base.:+","text":"+(A::Point, v::Vec)\n+(v::Vec, A::Point)\n\nReturn the point at the end of the vector v placed at a reference (or start) point A.\n\n\n\n\n\n","category":"method"},{"location":"points.html#Base.:--Tuple{Point, StaticArrays.SVector}","page":"Points","title":"Base.:-","text":"-(A::Point, v::Vec)\n-(v::Vec, A::Point)\n\nReturn the point at the end of the vector -v placed at a reference (or start) point A.\n\n\n\n\n\n","category":"method"},{"location":"points.html#Base.isapprox-Tuple{Point, Point}","page":"Points","title":"Base.isapprox","text":"isapprox(A::Point, B::Point)\n\nTells whether or not the coordinates of points A and B are approximately equal.\n\n\n\n\n\n","category":"method"},{"location":"neighborhoods.html#Neighborhoods","page":"Neighborhoods","title":"Neighborhoods","text":"","category":"section"},{"location":"neighborhoods.html","page":"Neighborhoods","title":"Neighborhoods","text":"Neighborhood\nMetricBall","category":"page"},{"location":"neighborhoods.html#Meshes.Neighborhood","page":"Neighborhoods","title":"Meshes.Neighborhood","text":"Neighborhood\n\nA neighborhood is a geometry that is not attached to any specific point in space, and is free to slide over a domain of interest.\n\n\n\n\n\n","category":"type"},{"location":"neighborhoods.html#Meshes.MetricBall","page":"Neighborhoods","title":"Meshes.MetricBall","text":"MetricBall(radii, rotation=nothing)\nMetricBall(radius, metric=Euclidean())\n\nA metric ball is a neighborhood that can be expressed in terms of a metric and a set of radii. The two main examples are the Euclidean ball an the Mahalanobis (ellipsoid) ball.\n\nWhen multiple radii are provided, they can be rotated by a rotation specification from the ReferenceFrameRotations.jl package. Alternatively, a metric from the Distances.jl package can be specified together with a single radius.\n\nExamples\n\nN-dimensional Euclidean ball with radius 1.0:\n\njulia> euclidean = MetricBall(1.0)\n\nAxis-aligned 3D ellispoid with radii (3.0, 2.0, 1.0):\n\njulia> mahalanobis = MetricBall((3.0, 2.0, 1.0))\n\n\n\n\n\n","category":"type"},{"location":"algorithms/hulls.html#Hulls","page":"Hulls","title":"Hulls","text":"","category":"section"},{"location":"algorithms/hulls.html","page":"Hulls","title":"Hulls","text":"hull\nHullMethod","category":"page"},{"location":"algorithms/hulls.html#Meshes.hull","page":"Hulls","title":"Meshes.hull","text":"hull(object, method)\n\nCompute the hull of object with given method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/hulls.html#Meshes.HullMethod","page":"Hulls","title":"Meshes.HullMethod","text":"HullMethod\n\nA method for computing hulls of point sets or collections of geometries.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/hulls.html#Graham's-scan","page":"Hulls","title":"Graham's scan","text":"","category":"section"},{"location":"algorithms/hulls.html","page":"Hulls","title":"Hulls","text":"GrahamScan","category":"page"},{"location":"algorithms/hulls.html#Meshes.GrahamScan","page":"Hulls","title":"Meshes.GrahamScan","text":"GrahamScan\n\nCompute the convex hull of a set of points or geometries using the Graham's scan method. See https://en.wikipedia.org/wiki/Graham_scan.\n\nThe method has complexity O(n*log(n)) where n is the number of points.\n\nReferences\n\nCormen et al. 2009. Introduction to Algorithms\n\n\n\n\n\n","category":"type"},{"location":"algorithms/hulls.html","page":"Hulls","title":"Hulls","text":"using Meshes, MeshViz\nimport CairoMakie as Mke\n\npset = PointSet(rand(Point2, 100))\nchul = hull(pset, GrahamScan())\n\nfig = Mke.Figure(resolution = (800, 400))\nviz(fig[1,1], chul)\nviz!(fig[1,1], pset, color = :black)\nfig","category":"page"},{"location":"algorithms/partitioning.html#Partition","page":"Partition","title":"Partition","text":"","category":"section"},{"location":"algorithms/partitioning.html","page":"Partition","title":"Partition","text":"partition\nPartitionMethod","category":"page"},{"location":"algorithms/partitioning.html#Meshes.partition","page":"Partition","title":"Meshes.partition","text":"partition(object, method)\n\nPartition object with partition method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/partitioning.html#Meshes.PartitionMethod","page":"Partition","title":"Meshes.PartitionMethod","text":"PartitionMethod\n\nA method for partitioning domain/data objects.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Uniform","page":"Partition","title":"Uniform","text":"","category":"section"},{"location":"algorithms/partitioning.html","page":"Partition","title":"Partition","text":"UniformPartition","category":"page"},{"location":"algorithms/partitioning.html#Meshes.UniformPartition","page":"Partition","title":"Meshes.UniformPartition","text":"UniformPartition(k, [shuffle])\n\nA method for partitioning spatial objects uniformly into k subsets of approximately equal size. Optionally shuffle the data (default to true).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Fraction","page":"Partition","title":"Fraction","text":"","category":"section"},{"location":"algorithms/partitioning.html","page":"Partition","title":"Partition","text":"FractionPartition","category":"page"},{"location":"algorithms/partitioning.html#Meshes.FractionPartition","page":"Partition","title":"Meshes.FractionPartition","text":"FractionPartition(fraction, shuffle=true)\n\nA method for partitioning spatial objects according to a given fraction. Optionally shuffle elements before partitioning.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Block","page":"Partition","title":"Block","text":"","category":"section"},{"location":"algorithms/partitioning.html","page":"Partition","title":"Partition","text":"BlockPartition","category":"page"},{"location":"algorithms/partitioning.html#Meshes.BlockPartition","page":"Partition","title":"Meshes.BlockPartition","text":"BlockPartition(sides; neighbors=false)\nBlockPartition(side₁, side₂, ...; neighbors=false)\n\nA method for partitioning spatial objects into blocks of given sides. Optionally, compute the neighbors of a block as the metadata.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Bisect-Point","page":"Partition","title":"Bisect-Point","text":"","category":"section"},{"location":"algorithms/partitioning.html","page":"Partition","title":"Partition","text":"BisectPointPartition","category":"page"},{"location":"algorithms/partitioning.html#Meshes.BisectPointPartition","page":"Partition","title":"Meshes.BisectPointPartition","text":"BisectPointPartition(normal, point)\n\nA method for partitioning spatial objects into two half spaces defined by a normal direction and a reference point.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Bisect-Fraction","page":"Partition","title":"Bisect-Fraction","text":"","category":"section"},{"location":"algorithms/partitioning.html","page":"Partition","title":"Partition","text":"BisectFractionPartition","category":"page"},{"location":"algorithms/partitioning.html#Meshes.BisectFractionPartition","page":"Partition","title":"Meshes.BisectFractionPartition","text":"BisectFractionPartition(normal, fraction=0.5, maxiter=10)\n\nA method for partitioning spatial objects into two half spaces defined by a normal direction and a fraction of points. The partition is returned within maxiter bisection iterations.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Ball","page":"Partition","title":"Ball","text":"","category":"section"},{"location":"algorithms/partitioning.html","page":"Partition","title":"Partition","text":"BallPartition","category":"page"},{"location":"algorithms/partitioning.html#Meshes.BallPartition","page":"Partition","title":"Meshes.BallPartition","text":"BallPartition(radius; metric=Euclidean())\n\nA method for partitioning spatial objects into balls of a given radius using a metric.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Plane","page":"Partition","title":"Plane","text":"","category":"section"},{"location":"algorithms/partitioning.html","page":"Partition","title":"Partition","text":"PlanePartition","category":"page"},{"location":"algorithms/partitioning.html#Meshes.PlanePartition","page":"Partition","title":"Meshes.PlanePartition","text":"PlanePartition(normal; tol=1e-6)\n\nA method for partitioning spatial objects into a family of hyperplanes defined by a normal direction. Two points x and y belong to the same hyperplane when (x - y) ⋅ normal < tol.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Direction","page":"Partition","title":"Direction","text":"","category":"section"},{"location":"algorithms/partitioning.html","page":"Partition","title":"Partition","text":"DirectionPartition","category":"page"},{"location":"algorithms/partitioning.html#Meshes.DirectionPartition","page":"Partition","title":"Meshes.DirectionPartition","text":"DirectionPartition(direction; tol=1e-6)\n\nA method for partitioning spatial objects along a given direction with bandwidth tolerance tol.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Predicate","page":"Partition","title":"Predicate","text":"","category":"section"},{"location":"algorithms/partitioning.html","page":"Partition","title":"Partition","text":"PredicatePartition","category":"page"},{"location":"algorithms/partitioning.html#Meshes.PredicatePartition","page":"Partition","title":"Meshes.PredicatePartition","text":"PredicatePartition(predicate)\n\nA method for partitioning spatial objects with a given predicate function. Two locations i and j are part of the same subset whenever predicate(i, j) == true\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#SpatialPredicate","page":"Partition","title":"SpatialPredicate","text":"","category":"section"},{"location":"algorithms/partitioning.html","page":"Partition","title":"Partition","text":"SpatialPredicatePartition","category":"page"},{"location":"algorithms/partitioning.html#Meshes.SpatialPredicatePartition","page":"Partition","title":"Meshes.SpatialPredicatePartition","text":"SpatialPredicatePartition(predicate)\n\nA method for partitioning spatial objects with a given spatial predicate function. Two coordinates x and y are part of the same subset whenever predicate(x, y) == true.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Product","page":"Partition","title":"Product","text":"","category":"section"},{"location":"algorithms/partitioning.html","page":"Partition","title":"Partition","text":"ProductPartition","category":"page"},{"location":"algorithms/partitioning.html#Meshes.ProductPartition","page":"Partition","title":"Meshes.ProductPartition","text":"ProductPartition(p₁, p₂)\n\nA method for partitioning spatial objects using the product of two partitioning methods p₁ and p₂.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Hierarchical","page":"Partition","title":"Hierarchical","text":"","category":"section"},{"location":"algorithms/partitioning.html","page":"Partition","title":"Partition","text":"HierarchicalPartition","category":"page"},{"location":"algorithms/partitioning.html#Meshes.HierarchicalPartition","page":"Partition","title":"Meshes.HierarchicalPartition","text":"HierarchicalPartition(first, second)\n\nA partitioning method in which a first partition is applied and then a second partition is applied to each subset of the first.\n\n\n\n\n\n","category":"type"},{"location":"about/license.html","page":"License","title":"License","text":"The Meshes.jl project is licensed under the MIT license:","category":"page"},{"location":"about/license.html","page":"License","title":"License","text":"Copyright (c) 2019-2020 Júlio Hoffimann, Simon Danisch, Arsh Sharma, Anshul Singhvi,\nMartijn Visser, Daniel Schwabeneder, F Freyer, Steve Kelly, Tim Holy, Matija Čufar,\nBenoît Legat, Erik Schenetter, Jan Weidner, Mohamed Tarek, Paul Jurczak,\nZachary P. Christensen, Andrew Bylard, Yuval\n\nLicensed under the MIT license.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","category":"page"},{"location":"traits.html#Traits","page":"Traits","title":"Traits","text":"","category":"section"},{"location":"traits.html","page":"Traits","title":"Traits","text":"This package defines two main traits:","category":"page"},{"location":"traits.html","page":"Traits","title":"Traits","text":"Domain\nData","category":"page"},{"location":"traits.html#Meshes.Domain","page":"Traits","title":"Meshes.Domain","text":"Domain{Dim,T}\n\nA domain is an indexable collection of geometries (e.g. mesh) or points For example, a collection of polygonal areas representing the states of a country can be seen as a domain.\n\n\n\n\n\n","category":"type"},{"location":"traits.html#Meshes.Data","page":"Traits","title":"Meshes.Data","text":"Data\n\nA domain implementing the Domain trait together with tables of values for geometries of the domain.\n\nSee also meshdata.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/simplification.html#Simplification","page":"Simplification","title":"Simplification","text":"","category":"section"},{"location":"algorithms/simplification.html","page":"Simplification","title":"Simplification","text":"simplify\ndecimate\nSimplificationMethod","category":"page"},{"location":"algorithms/simplification.html#Meshes.simplify","page":"Simplification","title":"Meshes.simplify","text":"simplify(object, method)\n\nSimplify object with given method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/simplification.html#Meshes.decimate","page":"Simplification","title":"Meshes.decimate","text":"decimate(object, ϵ)\n\nSimplify object with an appropriate simplification method and tolerance ϵ.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/simplification.html#Meshes.SimplificationMethod","page":"Simplification","title":"Meshes.SimplificationMethod","text":"SimplificationMethod\n\nA method for simplifying geometric objects.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/simplification.html#Douglas-Peucker","page":"Simplification","title":"Douglas-Peucker","text":"","category":"section"},{"location":"algorithms/simplification.html","page":"Simplification","title":"Simplification","text":"DouglasPeucker","category":"page"},{"location":"algorithms/simplification.html#Meshes.DouglasPeucker","page":"Simplification","title":"Meshes.DouglasPeucker","text":"DouglasPeucker(ϵ)\n\nThe Douglas-Peucker algorithm for simplifying polygonal chains or polygonal areas given a deviation tolerance ϵ.\n\nReferences\n\nDouglas, D. and Peucker, T. 1973. Algorithms for the Reduction of the Number of Points Required to Represent a Digitized Line or its Caricature\n\n\n\n\n\n","category":"type"},{"location":"algorithms/simplification.html","page":"Simplification","title":"Simplification","text":"using Meshes, MeshViz\nimport CairoMakie as Mke\n\n# polygonal area\npolyarea = PolyArea([(0.22926679, 0.47329807), (0.23094065, 0.44913536), (0.2569517, 0.38217533),\n                     (0.3072999, 0.272418), (0.34814754, 0.18421611), (0.37949452, 0.11756973),\n                     (0.4013409, 0.07247882), (0.41368666, 0.048943404), (0.42597583, 0.031655528),\n                     (0.4382084, 0.0206152), (0.45038435, 0.015822414), (0.4625037, 0.017277176),\n                     (0.47175184, 0.02439156), (0.47812873, 0.03716557), (0.4816344, 0.055599205),\n                     (0.48226887, 0.07969247), (0.48172843, 0.10446181), (0.4800131, 0.12990724),\n                     (0.47712287, 0.15602873), (0.47305775, 0.18282633), (0.47093934, 0.20558843),\n                     (0.47076762, 0.22431506), (0.47254258, 0.23900622), (0.47626427, 0.24966191),\n                     (0.47768936, 0.25845313), (0.47681788, 0.26537988), (0.4736498, 0.27044216),\n                     (0.46818516, 0.27363995), (0.4613889, 0.27232954), (0.45326096, 0.2665109),\n                     (0.44380143, 0.256184), (0.43301025, 0.24134888), (0.4246466, 0.22978415),\n                     (0.41871038, 0.22148979), (0.4152017, 0.21646582), (0.4141205, 0.21471222),\n                     (0.41227448, 0.21589448), (0.40966362, 0.22001258), (0.40628797, 0.22706655),\n                     (0.40214747, 0.23705636), (0.40200475, 0.24653101), (0.40585983, 0.25549048),\n                     (0.41371268, 0.2639348), (0.4255633, 0.2718639), (0.4378565, 0.28495985),\n                     (0.4505922, 0.30322257), (0.46377045, 0.32665208), (0.47739124, 0.35524836),\n                     (0.5046394, 0.36442512), (0.5455148, 0.35418236), (0.60001767, 0.32452005),\n                     (0.66814786, 0.27543822), (0.7186763, 0.24664374), (0.75160307, 0.23813659),\n                     (0.76692814, 0.2499168), (0.7646515, 0.28198436), (0.7769703, 0.29925033),\n                     (0.8038847, 0.3017147), (0.84539455, 0.28937748), (0.9015, 0.26223865),\n                     (0.94408435, 0.24899776), (0.9731477, 0.24965483), (0.98869, 0.26420987),\n                     (0.9907113, 0.29266283), (0.9849871, 0.31338844), (0.97151726, 0.32638666),\n                     (0.950302, 0.3316575), (0.9213412, 0.32920095), (0.8798396, 0.34078467),\n                     (0.8257972, 0.36640862), (0.7592141, 0.40607283), (0.6800901, 0.4597773),\n                     (0.6450007, 0.49104902), (0.6539457, 0.49988794), (0.7069251, 0.48629412),\n                     (0.803939, 0.45026752), (0.877913, 0.4226481), (0.9288472, 0.40343583),\n                     (0.9567415, 0.39263073), (0.961596, 0.39023277), (0.9419039, 0.40523484),\n                     (0.89766514, 0.43763688), (0.8288798, 0.48743892), (0.7355478, 0.55464095),\n                     (0.6655121, 0.60063523), (0.6187727, 0.6254217), (0.5953296, 0.62900037),\n                     (0.5951828, 0.6113712), (0.57516366, 0.60261106), (0.53527224, 0.6027198),\n                     (0.4755085, 0.6116975), (0.3958725, 0.6295441), (0.33913234, 0.6398651),\n                     (0.30528808, 0.6426605), (0.2943397, 0.6379303), (0.30628717, 0.6256744),\n                     (0.32149008, 0.6093727), (0.33994842, 0.5890249), (0.36166218, 0.5646312),\n                     (0.38663134, 0.5361916), (0.3919681, 0.520893), (0.3776725, 0.5187355),\n                     (0.34374446, 0.52971905), (0.29018405, 0.5538437), (0.25439468, 0.5678829),\n                     (0.2363764, 0.5718367), (0.23612918, 0.56570506), (0.25365302, 0.549488),\n                     (0.2733971, 0.5246488), (0.29536137, 0.49118724), (0.3195459, 0.4491035),\n                     (0.34595063, 0.39839754), (0.3647463, 0.3590396), (0.37593287, 0.33102974),\n                     (0.37951034, 0.31436795), (0.37547874, 0.30905423), (0.36070493, 0.3204269),\n                     (0.33518887, 0.348486), (0.29893062, 0.3932315), (0.25193012, 0.45466346),\n                     (0.22926679, 0.47329807)])\n\nsimp1 = simplify(polyarea, DouglasPeucker(0.01))\nsimp2 = simplify(polyarea, DouglasPeucker(0.05))\nsimp3 = simplify(polyarea, DouglasPeucker(0.10))\n\nfig = Mke.Figure(resolution = (800, 800))\nviz(fig[1,1], polyarea)\nviz(fig[1,2], simp1)\nviz(fig[2,1], simp2)\nviz(fig[2,2], simp3)\nfig","category":"page"},{"location":"meshes.html#Meshes","page":"Meshes","title":"Meshes","text":"","category":"section"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"Meshes can be constructed directly (e.g. CartesianGrid) or based on other constructs such as connectivity lists and topological structures (e.g. SimpleMesh).","category":"page"},{"location":"meshes.html#Overview","page":"Meshes","title":"Overview","text":"","category":"section"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"Mesh\nCartesianGrid\nSimpleMesh","category":"page"},{"location":"meshes.html#Meshes.Mesh","page":"Meshes","title":"Meshes.Mesh","text":"Mesh{Dim,T}\n\nA mesh embedded in a Dim-dimensional space with coordinates of type T.\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Meshes.CartesianGrid","page":"Meshes","title":"Meshes.CartesianGrid","text":"CartesianGrid(dims, origin, spacing)\n\nA Cartesian grid with dimensions dims, lower left corner at origin and cell spacing spacing. The three arguments must have the same length.\n\nCartesianGrid(start, finish, dims=dims)\n\nAlternatively, construct a Cartesian grid from a start point (lower left) to a finish point (upper right).\n\nCartesianGrid(start, finish, spacing)\n\nAlternatively, construct a Cartesian grid from a start point to a finish point using a given spacing.\n\nCartesianGrid(dims)\nCartesianGrid(dim1, dim2, ...)\n\nFinally, a Cartesian grid can be constructed by only passing the dimensions dims as a tuple, or by passing each dimension dim1, dim2, ... separately. In this case, the origin and spacing default to (0,0,...) and (1,1,...).\n\nExamples\n\nCreate a 3D grid with 100x100x50 locations:\n\njulia> CartesianGrid(100,100,50)\n\nCreate a 2D grid with 100x100 locations and origin at (10.,20.) units:\n\njulia> CartesianGrid((100,100),(10.,20.),(1.,1.))\n\nCreate a 1D grid from -1 to 1 with 100 locations:\n\njulia> CartesianGrid((-1.,),(1.,), dims=(100,))\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Meshes.SimpleMesh","page":"Meshes","title":"Meshes.SimpleMesh","text":"SimpleMesh(points, connec)\n\nA simple mesh with points and connectivities connec. The i-th face of the mesh is lazily built based on the connectivity list connec[i].\n\nSimpleMesh(points, topology)\n\nAlternatively, construct a simple mesh with points and a topological data structure (e.g. HalfEdgeTopology).\n\nSee also Topology.\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Examples","page":"Meshes","title":"Examples","text":"","category":"section"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"using Meshes\n\n# 3D Cartesian grid\ngrid = CartesianGrid(10, 10, 10)","category":"page"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"using MeshViz\nimport CairoMakie\n\nviz(grid, showfacets = true)","category":"page"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"# global vector of 2D points\npoints = Point2[(0,0),(1,0),(0,1),(1,1),(0.25,0.5),(0.75,0.5)]\n\n# connect the points into N-gon\nconnec = connect.([(1,2,6,5),(2,4,6),(4,3,5,6),(3,1,5)], Ngon)","category":"page"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"# 2D mesh made of N-gon elements\nmesh = SimpleMesh(points, connec)","category":"page"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"viz(mesh, showfacets = true)","category":"page"},{"location":"meshes.html#Connectivities","page":"Meshes","title":"Connectivities","text":"","category":"section"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"Connectivity\nconnect\nmaterialize","category":"page"},{"location":"meshes.html#Meshes.Connectivity","page":"Meshes","title":"Meshes.Connectivity","text":"Connectivity{PL,N}\n\nA connectivity list of N indices representing a Polytope of type PL. Indices are taken from a global vector of Point.\n\nConnectivity objects are constructed with the connect function.\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Meshes.connect","page":"Meshes","title":"Meshes.connect","text":"connect(indices, [PL])\n\nConnect a list of indices from a global vector of Point into a Polytope of type PL.\n\nThe type PL can be a Ngon in which case the length of the indices is used to identify the actual N-gon type (e.g. Triangle).\n\nFinally, the type PL can be ommitted. In this case, the indices are assumed to be connected as a Ngon or as a Segment.\n\nExamples\n\nConnect indices into a Triangle:\n\nconnect((1,2,3), Triangle)\n\nConnect indices into N-gons, a Triangle and a Quadrangle:\n\nconnect.([(1,2,3), (2,3,4,5)], Ngon)\n\nConnect indices into N-gon or segment:\n\nconnect((1,2)) # Segment\nconnect((1,2,3)) # Triangle\nconnect((1,2,3,4)) # Quadrangle\n\n\n\n\n\n","category":"function"},{"location":"meshes.html#Meshes.materialize","page":"Meshes","title":"Meshes.materialize","text":"materialize(connec, points)\n\nMaterialize a face using the connec list and a global vector of points.\n\n\n\n\n\n","category":"function"},{"location":"meshes.html#Topology","page":"Meshes","title":"Topology","text":"","category":"section"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"Topology\nFullTopology\nGridTopology\nHalfEdgeTopology","category":"page"},{"location":"meshes.html#Meshes.Topology","page":"Meshes","title":"Meshes.Topology","text":"Topology\n\nA data structure for constructing topological relations in a Mesh.\n\nReferences\n\nFloriani, L. & Hui, A. 2007. Shape representations based on simplicial and cell complexes\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Meshes.FullTopology","page":"Meshes","title":"Meshes.FullTopology","text":"FullTopology(connectivities)\n\nA data structure that stores all connectivities of a mesh.\n\nNotes\n\nThis data structure is sometimes referred to as the \"soup of geometries\". It does not support topological relations and is therefore incompatible with algorithms that rely on neighborhood search. It is still useful for mesh visualization and IO operations.\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Meshes.GridTopology","page":"Meshes","title":"Meshes.GridTopology","text":"GridTopology(dims)\n\nA data structure for grid topologies with dims elements.\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Meshes.HalfEdgeTopology","page":"Meshes","title":"Meshes.HalfEdgeTopology","text":"HalfEdgeTopology(elements)\nHalfEdgeTopology(halfedges)\n\nA data structure for orientable 2-manifolds based on half-edges constructed from a vector of connectivity elements or from a vector of pairs of halfedges.\n\nExamples\n\nConstruct half-edge topology from a list of top-faces:\n\nelements = connect.([(1,2,3),(3,2,4,5)])\ntopology = HalfEdgeTopology(elements)\n\nSee also Topology.\n\nReferences\n\nKettner, L. (1999). Using generic programming for designing a data structure for polyhedral surfaces\n\nNotes\n\nTwo types of half-edges exist (Kettner 1999). This implementation is the most common type that splits the incident elements.\nA vector of halfedges together with a dictionary of half4elem and a dictionary of half4vert can be used to retrieve topolological relations in optimal time. In this case, half4vert[i] returns the index of the half-edge in halfedges with head equal to i. Similarly, half4elem[i] returns the index of a half-edge in halfedges that is in the element i. Additionally, a dictionary edge4pair returns the index of the edge (i.e. two halves) for a given pair of vertices.\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Relations","page":"Meshes","title":"Relations","text":"","category":"section"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"TopologicalRelation\nBoundary\nCoboundary\nAdjacency","category":"page"},{"location":"meshes.html#Meshes.TopologicalRelation","page":"Meshes","title":"Meshes.TopologicalRelation","text":"TopologicalRelation\n\nA topological relation between faces of a Mesh implemented for a given Topology.\n\nAn object implementing this trait is a functor that can be evaluated at an integer index representing the face.\n\nExamples\n\n# create boundary relation mapping\n# 2-faces to 0-faces (i.e. vertices)\n∂ = Boundary{2,0}(topology)\n\n# list of vertices for first face\n∂(1)\n\nReferences\n\nFloriani, L. & Hui, A. 2007. Shape representations based on simplicial and cell complexes\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Meshes.Boundary","page":"Meshes","title":"Meshes.Boundary","text":"Boundary{P,Q}(topology)\n\nThe boundary relation from rank P to smaller rank Q for a given topology.\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Meshes.Coboundary","page":"Meshes","title":"Meshes.Coboundary","text":"Coboundary{P,Q}(topology)\n\nThe co-boundary relation from rank P to greater rank Q for a given topology.\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Meshes.Adjacency","page":"Meshes","title":"Meshes.Adjacency","text":"Adjacency{P}(topology)\n\nThe adjacency relation of rank P for a given topology.\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Examples-2","page":"Meshes","title":"Examples","text":"","category":"section"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"# global vector of 2D points\npoints = Point2[(0,0),(1,0),(0,1),(1,1),(0.25,0.5),(0.75,0.5)]\n\n# connect the points into N-gon\nconnec = connect.([(1,2,6,5),(2,4,6),(4,3,5,6),(3,1,5)], Ngon)\n\n# 2D mesh made of N-gon elements\nmesh = SimpleMesh(points, connec)","category":"page"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"# convert topology to half-edge topology\ntopo = convert(HalfEdgeTopology, topology(mesh))\n\n# boundary relation from faces (dim=2) to edges (dim=1)\n∂₂₁ = Boundary{2,1}(topo)\n\n# show boundary of first n-gon\n∂₂₁(1)","category":"page"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"# co-boundary relation from edges (dim=1) to faces(dim=2)\n𝒞₁₂ = Coboundary{1,2}(topo)\n\n# show n-gons that share edge 3\n𝒞₁₂(3)","category":"page"},{"location":"meshdata.html#Mesh-data","page":"Mesh data","title":"Mesh data","text":"","category":"section"},{"location":"meshdata.html","page":"Mesh data","title":"Mesh data","text":"Data can be attached to any type implementing the Domain trait. In particular, it is common to attach data to geometries of a mesh.","category":"page"},{"location":"meshdata.html","page":"Mesh data","title":"Mesh data","text":"MeshData\nmeshdata","category":"page"},{"location":"meshdata.html#Meshes.MeshData","page":"Mesh data","title":"Meshes.MeshData","text":"MeshData(domain, values)\n\nA domain together with a dictionary of data values. For each rank r (or parametric dimension) there can exist a corresponding Tables.jl table values[r]. The helper function meshdata is recommended instead of the raw constructor of the type.\n\n\n\n\n\n","category":"type"},{"location":"meshdata.html#Meshes.meshdata","page":"Mesh data","title":"Meshes.meshdata","text":"meshdata(domain, values)\n\nCreate spatial data from a domain implementing the the Domain trait and a dictionary of data values where values[r] holds a Tables.jl table for the rank r.\n\nExamples\n\n# attach temperature and pressure to grid elements\nmeshdata(CartesianGrid(10,10),\n  Dict(2 => (temperature=rand(100), pressure=rand(100)))\n)\n\n\n\n\n\nmeshdata(vertices, elements, values)\n\nCreate spatial data from a SimpleMesh with vertices and elements, and a dictionary of data values.\n\nExamples\n\n# vertices and elements\nvertices = Point2[(0,0),(1,0),(1,1),(0,1)]\nelements = connect.([(1,2,3),(3,4,1)])\n\n# attach data to ranks 0 and 2\nmeshdata(vertices, elements,\n  Dict(\n    0 => (temperature=[1.0,2.0,3.0,4.0], pressure=[4.0,3.0,2.0,1.0]),\n    2 => (quality=[\"A\",\"B\"], state=[true,false])\n  )\n)\n\n\n\n\n\nmeshdata(domain; vtable, etable)\n\nCreate spatial data from a domain, a table vtable with data for the vertices, and a table etable with data for the elements.\n\nExamples\n\nmeshdata(CartesianGrid(10,10),\n  etable = (temperature=rand(100), pressure=rand(100))\n)\n\n\n\n\n\nmeshdata(vertices, elements; vtable, etable)\n\nCreate spatial data from a SimpleMesh with vertices and elements, a table vtable with data for the vertices, and a table etable with data for the elements.\n\nExamples\n\n# vertices and elements\nvertices = Point2[(0,0),(1,0),(1,1),(0,1)]\nelements = connect.([(1,2,3),(3,4,1)])\n\n# attach data to mesh\nmeshdata(vertices, elements,\n  vtable = (temperature=[1.0,2.0,3.0,4.0], pressure=[4.0,3.0,2.0,1.0]),\n  etable = (quality=[\"A\",\"B\"], state=[true,false])\n)\n\n\n\n\n\n","category":"function"},{"location":"algorithms/discretization.html#Discretization","page":"Discretization","title":"Discretization","text":"","category":"section"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"discretize\ndiscretizewithin\ntriangulate\nDiscretizationMethod\nBoundaryDiscretizationMethod","category":"page"},{"location":"algorithms/discretization.html#Meshes.discretize","page":"Discretization","title":"Meshes.discretize","text":"discretize(geometry, method)\n\nDiscretize geometry with discretization method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/discretization.html#Meshes.discretizewithin","page":"Discretization","title":"Meshes.discretizewithin","text":"discretizewithin(boundary, method)\n\nDiscretize geometry within boundary with boundary discretization method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/discretization.html#Meshes.triangulate","page":"Discretization","title":"Meshes.triangulate","text":"triangulate(object)\n\nTriangulate object of parametric dimension 2 into triangles using an appropriate triangulation method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/discretization.html#Meshes.DiscretizationMethod","page":"Discretization","title":"Meshes.DiscretizationMethod","text":"DiscretizationMethod\n\nA method for discretizing geometries into meshes.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/discretization.html#Meshes.BoundaryDiscretizationMethod","page":"Discretization","title":"Meshes.BoundaryDiscretizationMethod","text":"BoundaryDiscretizationMethod\n\nA method for discretizing geometries based on their boundary.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/discretization.html#FanTriangulation","page":"Discretization","title":"FanTriangulation","text":"","category":"section"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"FanTriangulation","category":"page"},{"location":"algorithms/discretization.html#Meshes.FanTriangulation","page":"Discretization","title":"Meshes.FanTriangulation","text":"FanTriangulation()\n\nThe fan triangulation algorithm for convex polygons. See https://en.wikipedia.org/wiki/Fan_triangulation.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"using Meshes, MeshViz\nimport CairoMakie as Mke\n\nhexagon = Hexagon((0.,0.), (1.,0.), (1.,1.),\n                  (0.75,1.5), (0.25,1.5), (0.,1.))\n\nmesh = discretize(hexagon, FanTriangulation())\n\nfig = Mke.Figure(resolution = (800, 400))\nviz(fig[1,1], hexagon)\nviz(fig[1,2], mesh, showfacets = true)\nfig","category":"page"},{"location":"algorithms/discretization.html#RegularDiscretization","page":"Discretization","title":"RegularDiscretization","text":"","category":"section"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"RegularDiscretization","category":"page"},{"location":"algorithms/discretization.html#Meshes.RegularDiscretization","page":"Discretization","title":"Meshes.RegularDiscretization","text":"RegularDiscretization(n1, n2, ..., np)\n\nA method to discretize primitive geometries using regular samples along each parametric dimension. The number of samples n1, n2, ..., np is passed to RegularSampling.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"sphere = Sphere((0.,0.,0.), 1.)\n\nmesh = discretize(sphere, RegularDiscretization(10,10))\n\nfig = Mke.Figure(resolution = (400, 400))\nviz(fig[1,1], mesh, showfacets = true)\nfig","category":"page"},{"location":"algorithms/discretization.html#Dehn1899","page":"Discretization","title":"Dehn1899","text":"","category":"section"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"Dehn1899","category":"page"},{"location":"algorithms/discretization.html#Meshes.Dehn1899","page":"Discretization","title":"Meshes.Dehn1899","text":"Dehn1899()\n\nMax Dehns' triangulation proved in 1899.\n\nThe algorithm is described in the first chapter of Devadoss & Rourke 2011, and is based on a theorem derived in 1899 by the German mathematician Max Dehn. See https://en.wikipedia.org/wiki/Twoearstheorem.\n\nBecause the algorithm relies on recursion, it is mostly appropriate for polygons with small number of vertices.\n\nReferences\n\nDevadoss, S & Rourke, J. 2011. Discrete and computational geometry\n\n\n\n\n\n","category":"type"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"# polygonal area\npolyarea = PolyArea([(0.22926679, 0.47329807), (0.23094065, 0.44913536), (0.2569517, 0.38217533),\n                     (0.3072999, 0.272418), (0.34814754, 0.18421611), (0.37949452, 0.11756973),\n                     (0.4013409, 0.07247882), (0.41368666, 0.048943404), (0.42597583, 0.031655528),\n                     (0.4382084, 0.0206152), (0.45038435, 0.015822414), (0.4625037, 0.017277176),\n                     (0.47175184, 0.02439156), (0.47812873, 0.03716557), (0.4816344, 0.055599205),\n                     (0.48226887, 0.07969247), (0.48172843, 0.10446181), (0.4800131, 0.12990724),\n                     (0.47712287, 0.15602873), (0.47305775, 0.18282633), (0.47093934, 0.20558843),\n                     (0.47076762, 0.22431506), (0.47254258, 0.23900622), (0.47626427, 0.24966191),\n                     (0.47768936, 0.25845313), (0.47681788, 0.26537988), (0.4736498, 0.27044216),\n                     (0.46818516, 0.27363995), (0.4613889, 0.27232954), (0.45326096, 0.2665109),\n                     (0.44380143, 0.256184), (0.43301025, 0.24134888), (0.4246466, 0.22978415),\n                     (0.41871038, 0.22148979), (0.4152017, 0.21646582), (0.4141205, 0.21471222),\n                     (0.41227448, 0.21589448), (0.40966362, 0.22001258), (0.40628797, 0.22706655),\n                     (0.40214747, 0.23705636), (0.40200475, 0.24653101), (0.40585983, 0.25549048),\n                     (0.41371268, 0.2639348), (0.4255633, 0.2718639), (0.4378565, 0.28495985),\n                     (0.4505922, 0.30322257), (0.46377045, 0.32665208), (0.47739124, 0.35524836),\n                     (0.5046394, 0.36442512), (0.5455148, 0.35418236), (0.60001767, 0.32452005),\n                     (0.66814786, 0.27543822), (0.7186763, 0.24664374), (0.75160307, 0.23813659),\n                     (0.76692814, 0.2499168), (0.7646515, 0.28198436), (0.7769703, 0.29925033),\n                     (0.8038847, 0.3017147), (0.84539455, 0.28937748), (0.9015, 0.26223865),\n                     (0.94408435, 0.24899776), (0.9731477, 0.24965483), (0.98869, 0.26420987),\n                     (0.9907113, 0.29266283), (0.9849871, 0.31338844), (0.97151726, 0.32638666),\n                     (0.950302, 0.3316575), (0.9213412, 0.32920095), (0.8798396, 0.34078467),\n                     (0.8257972, 0.36640862), (0.7592141, 0.40607283), (0.6800901, 0.4597773),\n                     (0.6450007, 0.49104902), (0.6539457, 0.49988794), (0.7069251, 0.48629412),\n                     (0.803939, 0.45026752), (0.877913, 0.4226481), (0.9288472, 0.40343583),\n                     (0.9567415, 0.39263073), (0.961596, 0.39023277), (0.9419039, 0.40523484),\n                     (0.89766514, 0.43763688), (0.8288798, 0.48743892), (0.7355478, 0.55464095),\n                     (0.6655121, 0.60063523), (0.6187727, 0.6254217), (0.5953296, 0.62900037),\n                     (0.5951828, 0.6113712), (0.57516366, 0.60261106), (0.53527224, 0.6027198),\n                     (0.4755085, 0.6116975), (0.3958725, 0.6295441), (0.33913234, 0.6398651),\n                     (0.30528808, 0.6426605), (0.2943397, 0.6379303), (0.30628717, 0.6256744),\n                     (0.32149008, 0.6093727), (0.33994842, 0.5890249), (0.36166218, 0.5646312),\n                     (0.38663134, 0.5361916), (0.3919681, 0.520893), (0.3776725, 0.5187355),\n                     (0.34374446, 0.52971905), (0.29018405, 0.5538437), (0.25439468, 0.5678829),\n                     (0.2363764, 0.5718367), (0.23612918, 0.56570506), (0.25365302, 0.549488),\n                     (0.2733971, 0.5246488), (0.29536137, 0.49118724), (0.3195459, 0.4491035),\n                     (0.34595063, 0.39839754), (0.3647463, 0.3590396), (0.37593287, 0.33102974),\n                     (0.37951034, 0.31436795), (0.37547874, 0.30905423), (0.36070493, 0.3204269),\n                     (0.33518887, 0.348486), (0.29893062, 0.3932315), (0.25193012, 0.45466346),\n                     (0.22926679, 0.47329807)])\n\nmesh = discretize(polyarea, Dehn1899())\n\nfig = Mke.Figure(resolution = (800, 400))\nviz(fig[1,1], polyarea)\nviz(fig[1,2], mesh, showfacets = true)\nfig","category":"page"},{"location":"algorithms/discretization.html#FIST","page":"Discretization","title":"FIST","text":"","category":"section"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"FIST","category":"page"},{"location":"algorithms/discretization.html#Meshes.FIST","page":"Discretization","title":"Meshes.FIST","text":"FIST([rng]; shuffle=true)\n\nFast Industrial-Strength Triangulation (FIST) of polygons.\n\nThis triangulation method is the method behind the famous Mapbox's Earcut library. It is based on a ear clipping algorithm adapted for complex n-gons with holes. It has O(n²) time complexity where n is the number of vertices. In practice it is very efficient due to heuristics implemented in the algorithm.\n\nThe option shuffle is used to shuffle the order in which ears are clipped. It improves the quality of the triangles, which can be very sliver otherwise. Optionally, specify the random number generator rng.\n\nReferences\n\nHeld, M. 1998. FIST: Fast Industrial-Strength Triangulation of Polygons\nEder et al. 2018. Parallelized ear clipping for the triangulation and constrained Delaunay triangulation of polygons\n\n\n\n\n\n","category":"type"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"mesh = discretize(polyarea, FIST())\n\nfig = Mke.Figure(resolution = (800, 400))\nviz(fig[1,1], polyarea)\nviz(fig[1,2], mesh, showfacets = true)\nfig","category":"page"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"As can be seen in the following example, all discretization methods for Polygon automatically work in the presence of holes:","category":"page"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"outer = [(0.18142937, 0.54681134), (0.38282228, 0.107781954), (0.43220532, 0.013640274),\n         (0.48068276, 0.019459315), (0.48322055, 0.11583236), (0.46696007, 0.2230227),\n         (0.48184678, 0.2656454), (0.45998818, 0.2784367), (0.4168235, 0.2190962),\n         (0.4124987, 0.21208182), (0.39593673, 0.2520411), (0.44333926, 0.28375763),\n         (0.4978224, 0.3981428), (0.7703431, 0.20181546), (0.7612364, 0.33008572),\n         (0.9856581, 0.2215304), (0.99374324, 0.3353423), (0.9688778, 0.38663587),\n         (0.59554976, 0.655444), (0.59496254, 0.58492756), (0.27641845, 0.656314),\n         (0.3242084, 0.6072907), (0.42408508, 0.49353212), (0.20984341, 0.59003067),\n         (0.18142937, 0.54681134)]\n\ninners = [[(0.87789994, 0.32551613), (0.5614043, 0.540334), (0.9494598, 0.39622766), (0.87789994, 0.32551613)],\n          [(0.2799388, 0.52516246), (0.38555774, 0.32233855), (0.36943135, 0.30108362), (0.2799388, 0.52516246)]]\n\npolyarea = PolyArea(outer, inners)\n\nmesh = discretize(polyarea, FIST())\n\nfig = Mke.Figure(resolution = (800, 400))\nviz(fig[1,1], polyarea)\nviz(fig[1,2], mesh, showfacets = true)\nfig","category":"page"},{"location":"contributing/guidelines.html#Guidelines","page":"Guidelines","title":"Guidelines","text":"","category":"section"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"First off, thank you for considering contributing to Meshes.jl. Below are a few suggestions to speed up the collaboration process:","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"Please be polite, we are here to help and learn from each other.\nTry to explain your contribution with simple language.\nReferences to textbooks and papers are always welcome.\nFollow the coding standards in the source.","category":"page"},{"location":"contributing/guidelines.html#Reporting-issues","page":"Guidelines","title":"Reporting issues","text":"","category":"section"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"If you are experiencing issues or have discovered a bug, please report it on GitHub. To make the resolution process easier, please include the version of Julia and Meshes.jl in your writeup. These can be found with two commands:","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"julia> versioninfo()\njulia> using Pkg; Pkg.status()","category":"page"},{"location":"contributing/guidelines.html#Feature-requests","page":"Guidelines","title":"Feature requests","text":"","category":"section"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"If you have suggestions of improvement or algorithms that you would like to see implemented in Meshes.jl, please open an issue on GitHub. Suggestions as well as feature requests are very welcome.","category":"page"},{"location":"contributing/guidelines.html#Code-contribution","page":"Guidelines","title":"Code contribution","text":"","category":"section"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"If you have code that you would like to contribute to Meshes.jl, that is awesome! Please open an issue before you create the pull request on GitHub so that we make sure your idea is aligned with our goals for the project.","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"After your idea is discussed and revised by maintainers, please get the development version of the project by typing the following in the package manager:","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"] activate @dev","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"This will create a fresh environment called @dev where you can play with the project components without compromising your normal user environment.","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"] dev Meshes","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"This will clone all the project components in your ~/.julia folder so that you can modify it and submit a pull request on GitHub later. Don't hesitate to ask questions. We are looking forward to your contributions.","category":"page"},{"location":"algorithms/neighborsearch.html#Neighbor-search","page":"Neighbor search","title":"Neighbor search","text":"","category":"section"},{"location":"algorithms/neighborsearch.html","page":"Neighbor search","title":"Neighbor search","text":"search\nNeighborSearchMethod\nBallSearch\nKNearestSearch\nKBallSearch\nBoundedSearch","category":"page"},{"location":"algorithms/neighborsearch.html#Meshes.search","page":"Neighbor search","title":"Meshes.search","text":"search(pₒ, method, mask=nothing)\n\nReturn neighbors of point pₒ using method. Optionally, specify a mask for all indices of the domain.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/neighborsearch.html#Meshes.NeighborSearchMethod","page":"Neighbor search","title":"Meshes.NeighborSearchMethod","text":"NeighborSearchMethod\n\nA method for searching neighbors given a reference point.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/neighborsearch.html#Meshes.BallSearch","page":"Neighbor search","title":"Meshes.BallSearch","text":"BallSearch(domain, ball)\n\nA method for searching neighbors in domain inside ball.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/neighborsearch.html#Meshes.KNearestSearch","page":"Neighbor search","title":"Meshes.KNearestSearch","text":"KNearestSearch(domain, k; metric=Euclidean())\n\nA method for searching k nearest neighbors in domain according to metric.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/neighborsearch.html#Meshes.KBallSearch","page":"Neighbor search","title":"Meshes.KBallSearch","text":"KBallSearch(domain, k, ball)\n\nA method that searches k nearest neighbors and then filters these neighbors using a norm ball.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/neighborsearch.html#Meshes.BoundedSearch","page":"Neighbor search","title":"Meshes.BoundedSearch","text":"BoundedSearch(method, nmax)\n\nA method for searching at most nmax neighbors using method.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/intersection.html#Intersection","page":"Intersection","title":"Intersection","text":"","category":"section"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"Intersections are implemented for various geometries such as Segment, Line, and Box:","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"using Meshes\n\ns1 = Segment((0.0,0.0), (1.0,0.0))\ns2 = Segment((0.5,0.0), (2.0,0.0))\n\ns1 ∩ s2","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"First, the intersection function computes the Intersection object, which holds the IntersectionType besides the actual geometry:","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"I = intersection(s1, s2)","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"This object supports two methods type and get to retrieve the underlying information:","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"type(I)","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"get(I)","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"For performance-sensitive code, it is recommended to use the intersection method with three arguments, including a function to reduce the number of output types.","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"In the example below, we use the do syntax to restrict our attention to a subset of intersection types and to make the return type and Int value in all cases:","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"intersection(s1, s2) do I\n  if type(I) == CrossingSegments\n    return 1\n  elseif type(I) == OverlappingSegments\n    return 2\n  else\n    return 3\n  end\nend","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"IntersectionType\nIntersection\nintersection\nintersect(::Geometry, ::Geometry)","category":"page"},{"location":"algorithms/intersection.html#Meshes.IntersectionType","page":"Intersection","title":"Meshes.IntersectionType","text":"IntersectionType\n\nThe different types of intersection that may occur between geometries. Type IntersectionType in a Julia session to see the full list.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/intersection.html#Meshes.Intersection","page":"Intersection","title":"Meshes.Intersection","text":"Intersection{G}\n\nAn intersection between geometries holding a geometry of type G.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/intersection.html#Meshes.intersection","page":"Intersection","title":"Meshes.intersection","text":"intersection([f], g1, g2)\n\nCompute the intersection of two geometries g1 and g2 and apply function f to it. Default function is identity.\n\nExamples\n\nintersecttype(g1, g2) do I\n  if I isa CrossingLines\n    # do something\n  else\n    # do nothing\n  end\nend\n\nNotes\n\nWhen a custom function f is used that reduces the number of return types, Julia is able to optimize the branches of the code and generate specialized code. This is not the case when f === identity.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/intersection.html#Base.intersect-Tuple{Geometry, Geometry}","page":"Intersection","title":"Base.intersect","text":"g1 ∩ g2\n\nReturn the intersection of two geometries g1 and g2 as a new geometry.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"More generally, when the geometries are not convex nor simple, it is still possible to know whether or not they have an intersection:","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"hasintersect\nsupportfun","category":"page"},{"location":"algorithms/intersection.html#Meshes.hasintersect","page":"Intersection","title":"Meshes.hasintersect","text":"hasintersect(g1, g2)\n\nReturn true if geometries g1 and g2 intersect and false otherwise.\n\nThe algorithm works with any geometry that has a well-defined supportfun.\n\nReferences\n\nGilbert, E., Johnson, D., Keerthi, S. 1988. A fast Procedure for Computing the Distance Between Complex Objects in Three-Dimensional Space\n\n\n\n\n\n","category":"function"},{"location":"algorithms/intersection.html#Meshes.supportfun","page":"Intersection","title":"Meshes.supportfun","text":"supportfun(geometry, direction)\n\nSupport function of geometry for given direction.\n\nReferences\n\nGilbert, E., Johnson, D., Keerthi, S. 1988. A fast Procedure for Computing the Distance Between Complex Objects in Three-Dimensional Space\n\n\n\n\n\n","category":"function"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"outer = Point2[(0,0),(1,0),(1,1),(0,1),(0,0)]\nhole1 = Point2[(0.2,0.2),(0.4,0.2),(0.4,0.4),(0.2,0.4),(0.2,0.2)]\nhole2 = Point2[(0.6,0.2),(0.8,0.2),(0.8,0.4),(0.6,0.4),(0.6,0.2)]\npoly  = PolyArea(outer, [hole1, hole2])\nball1 = Ball((0.5,0.5), 0.05)\nball2 = Ball((0.3,0.3), 0.05)\nball3 = Ball((0.7,0.3), 0.05)\nball4 = Ball((0.3,0.3), 0.15)\n\nhasintersect(poly, ball1)","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"hasintersect(poly, ball2)","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"hasintersect(poly, ball3)","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"hasintersect(poly, ball4)","category":"page"},{"location":"algorithms/smoothing.html#Smoothing","page":"Smoothing","title":"Smoothing","text":"","category":"section"},{"location":"algorithms/smoothing.html","page":"Smoothing","title":"Smoothing","text":"smooth\nSmoothingMethod","category":"page"},{"location":"algorithms/smoothing.html#Meshes.smooth","page":"Smoothing","title":"Meshes.smooth","text":"smooth(mesh, method)\n\nSmooth mesh with given method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/smoothing.html#Meshes.SmoothingMethod","page":"Smoothing","title":"Meshes.SmoothingMethod","text":"SmoothingMethod\n\nA method for smoothing meshes.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/smoothing.html#Taubin","page":"Smoothing","title":"Taubin","text":"","category":"section"},{"location":"algorithms/smoothing.html","page":"Smoothing","title":"Smoothing","text":"TaubinSmoothing","category":"page"},{"location":"algorithms/smoothing.html#Meshes.TaubinSmoothing","page":"Smoothing","title":"Meshes.TaubinSmoothing","text":"TaubinSmoothing(n; λ=0.5, μ=-0.5)\n\nPerform n iterations of Taubin smoothing with parameters λ and μ.\n\nReferences\n\nTaubin, G. 1995. Curve and Surface Smoothing without Shrinkage\n\n\n\n\n\n","category":"type"},{"location":"algorithms/smoothing.html","page":"Smoothing","title":"Smoothing","text":"using Meshes\nusing MeshViz\nusing PlyIO\n\nimport CairoMakie as Mke\n\n# helper function to read *.ply files\nfunction readply(fname)\n  ply = load_ply(fname)\n  x = ply[\"vertex\"][\"x\"]\n  y = ply[\"vertex\"][\"y\"]\n  z = ply[\"vertex\"][\"z\"]\n  points = Point3.(x, y, z)\n  connec = [connect(Tuple(c.+1)) for c in ply[\"face\"][\"vertex_indices\"]]\n  SimpleMesh(points, connec)\nend\n\n# download mesh from the web\nfile = download(\n  \"https://raw.githubusercontent.com/juliohm/JuliaCon2021/master/data/beethoven.ply\"\n)\n\n# read mesh from disk\nmesh = readply(file)\n\n# smooth mesh with 30 iterations\nsmesh = smooth(mesh, TaubinSmoothing(30))\n\nfig = Mke.Figure(resolution = (800, 1200))\nviz(fig[1,1], mesh)\nviz(fig[2,1], smesh)\nfig","category":"page"},{"location":"geometries/primitives.html#Primitives","page":"Primitives","title":"Primitives","text":"","category":"section"},{"location":"geometries/primitives.html","page":"Primitives","title":"Primitives","text":"Primitive\nLine\nRay\nPlane\nBox\nCylinder\nBall\nSphere","category":"page"},{"location":"geometries/primitives.html#Meshes.Primitive","page":"Primitives","title":"Meshes.Primitive","text":"Primitive{Dim,T}\n\nWe say that a geometry is a primitive when it can be expressed as a single entity with no parts (a.k.a. atomic). For example, a sphere is a primitive described in terms of a mathematical expression involving a metric and a radius. See https://en.wikipedia.org/wiki/Geometric_primitive.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives.html#Meshes.Line","page":"Primitives","title":"Meshes.Line","text":"Line(a, b)\n\nA line passing through points a and b.\n\nSee also Segment.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives.html#Meshes.Ray","page":"Primitives","title":"Meshes.Ray","text":"Ray(p, v)\n\nA ray originating at point p, pointed in direction v. It can be called as r(t) with t > 0 to cast it at p + t * v.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives.html#Meshes.Plane","page":"Primitives","title":"Meshes.Plane","text":"Plane(p, u, v)\n\nA plane embedded in R³ passing through point p, defined by non-parallel vectors u and v.\n\nPlane(p, n)\n\nAlternatively specify point p and a given normal vector n to the plane.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives.html#Meshes.Box","page":"Primitives","title":"Meshes.Box","text":"Box(min, max)\n\nAn axis-aligned box with min and max corners. See https://en.wikipedia.org/wiki/Hyperrectangle.\n\nExamples\n\nBox(Point(0,0,0), Point(1,1,1)) # unit cube\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives.html#Meshes.Cylinder","page":"Primitives","title":"Meshes.Cylinder","text":"Cylinder(radius, bottom, top)\n\nA solid circular cylinder embedded in R³ with given radius, delimited by bottom and top planes.\n\nCylinder(radius, segment)\n\nAlternatively, construct a right circular cylinder with given radius and segment between origin of bottom and top planes.\n\nCylinder(radius)\n\nFinally, construct a right vertical circular cylinder with given radius.\n\nSee https://en.wikipedia.org/wiki/Cylinder. \n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives.html#Meshes.Ball","page":"Primitives","title":"Meshes.Ball","text":"Ball(center, radius)\n\nA ball with center and radius.\n\nSee also Sphere.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives.html#Meshes.Sphere","page":"Primitives","title":"Meshes.Sphere","text":"Sphere(center, radius)\n\nA sphere with center and radius.\n\nSee also Ball.\n\n\n\n\n\n","category":"type"},{"location":"vectors.html#Vectors","page":"Vectors","title":"Vectors","text":"","category":"section"},{"location":"vectors.html","page":"Vectors","title":"Vectors","text":"Vec","category":"page"},{"location":"vectors.html#Meshes.Vec","page":"Vectors","title":"Meshes.Vec","text":"Vec{Dim,T}\n\nA vector in Dim-dimensional space with coordinates of type T.\n\nA vector can be obtained by subtracting two Point objects.\n\nExamples\n\nA = Point(0.0, 0.0)\nB = Point(1.0, 0.0)\nv = B - A\n\nNotes\n\nA Vec is a SVector from StaticArrays.jl\nType aliases are Vec1, Vec2, Vec3, Vec1f, Vec2f, Vec3f\n\n\n\n\n\n","category":"type"},{"location":"algorithms/boundingbox.html#Bounding-box","page":"Bounding box","title":"Bounding box","text":"","category":"section"},{"location":"algorithms/boundingbox.html","page":"Bounding box","title":"Bounding box","text":"boundingbox","category":"page"},{"location":"algorithms/boundingbox.html#Meshes.boundingbox","page":"Bounding box","title":"Meshes.boundingbox","text":"boundingbox(geometry)\n\nAxis-aligned bounding box of the geometry.\n\n\n\n\n\nboundingbox(domain)\n\nAxis-aligned bounding box of the domain.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/boundingbox.html","page":"Bounding box","title":"Bounding box","text":"using Meshes, MeshViz\nimport CairoMakie as Mke\n\npset = PointSet(rand(Point2, 100))\nbbox = boundingbox(pset)\n\nfig = Mke.Figure(resolution = (800, 400))\nviz(fig[1,1], bbox)\nviz!(fig[1,1], pset, color = :black)\nfig","category":"page"},{"location":"algorithms/refinement.html#Refinement","page":"Refinement","title":"Refinement","text":"","category":"section"},{"location":"algorithms/refinement.html","page":"Refinement","title":"Refinement","text":"refine\nRefinementMethod","category":"page"},{"location":"algorithms/refinement.html#Meshes.refine","page":"Refinement","title":"Meshes.refine","text":"refine(mesh, method)\n\nRefine mesh with refinement method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/refinement.html#Meshes.RefinementMethod","page":"Refinement","title":"Meshes.RefinementMethod","text":"RefinementMethod\n\nA method for refining meshes.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/refinement.html#TriRefinement","page":"Refinement","title":"TriRefinement","text":"","category":"section"},{"location":"algorithms/refinement.html","page":"Refinement","title":"Refinement","text":"TriRefinement","category":"page"},{"location":"algorithms/refinement.html#Meshes.TriRefinement","page":"Refinement","title":"Meshes.TriRefinement","text":"TriRefinement()\n\nRefinement of polygonal meshes into triangles. A n-gon is subdivided into n-2 triangles.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/refinement.html","page":"Refinement","title":"Refinement","text":"using Meshes, MeshViz\nimport CairoMakie as Mke\n\ngrid = CartesianGrid(10, 10)\n\n# refine three times\nref1 = refine(grid, TriRefinement())\nref2 = refine(ref1, TriRefinement())\nref3 = refine(ref2, TriRefinement())\n\nfig = Mke.Figure(resolution = (800, 800))\nviz(fig[1,1], grid, showfacets = true, axis = (title = \"original\",))\nviz(fig[1,2], ref1, showfacets = true, axis = (title = \"refine 1\",))\nviz(fig[2,1], ref2, showfacets = true, axis = (title = \"refine 2\",))\nviz(fig[2,2], ref3, showfacets = true, axis = (title = \"refine 3\",))\nfig","category":"page"},{"location":"algorithms/refinement.html#QuadRefinement","page":"Refinement","title":"QuadRefinement","text":"","category":"section"},{"location":"algorithms/refinement.html","page":"Refinement","title":"Refinement","text":"QuadRefinement","category":"page"},{"location":"algorithms/refinement.html#Meshes.QuadRefinement","page":"Refinement","title":"Meshes.QuadRefinement","text":"QuadRefinement()\n\nRefinement of polygonal meshes into quadrangles. A n-gon is subdivided into n quadrangles.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/refinement.html","page":"Refinement","title":"Refinement","text":"using Meshes, MeshViz\nimport CairoMakie as Mke\n\n# define a cube in R^3\npoints = Point3[(0,0,0),(1,0,0),(1,1,0),(0,1,0),(0,0,1),(1,0,1),(1,1,1),(0,1,1)]\nconnec = connect.([(1,4,3,2),(5,6,7,8),(1,2,6,5),(3,4,8,7),(1,5,8,4),(2,3,7,6)])\nmesh   = SimpleMesh(points, connec)\n\n# refine three times\nref1 = refine(mesh, QuadRefinement())\nref2 = refine(ref1, QuadRefinement())\nref3 = refine(ref2, QuadRefinement())\n\nfig = Mke.Figure(resolution = (800, 800))\nviz(fig[1,1], mesh, showfacets = true, axis = (title = \"original\",))\nviz(fig[1,2], ref1, showfacets = true, axis = (title = \"refine 1\",))\nviz(fig[2,1], ref2, showfacets = true, axis = (title = \"refine 2\",))\nviz(fig[2,2], ref3, showfacets = true, axis = (title = \"refine 3\",))\nfig","category":"page"},{"location":"algorithms/refinement.html#Catmull-Clark","page":"Refinement","title":"Catmull-Clark","text":"","category":"section"},{"location":"algorithms/refinement.html","page":"Refinement","title":"Refinement","text":"CatmullClark","category":"page"},{"location":"algorithms/refinement.html#Meshes.CatmullClark","page":"Refinement","title":"Meshes.CatmullClark","text":"CatmullClark()\n\nCatmull-Clark refinement of polygonal meshes.\n\nStrictly speaking, the Catmull-Clark algorithm is used for subdivision surface modeling, not just mesh refinement. At each step of refinement, the vertices are adjusted to approximate a smooth surface.\n\nReferences\n\nCatmull & Clark. 1978. Recursively generated B-spline surfaces on arbitrary topological meshes\n\n\n\n\n\n","category":"type"},{"location":"algorithms/refinement.html","page":"Refinement","title":"Refinement","text":"using Meshes, MeshViz\nimport CairoMakie as Mke\n\n# define a cube in R^3\npoints = Point3[(0,0,0),(1,0,0),(1,1,0),(0,1,0),(0,0,1),(1,0,1),(1,1,1),(0,1,1)]\nconnec = connect.([(1,4,3,2),(5,6,7,8),(1,2,6,5),(3,4,8,7),(1,5,8,4),(2,3,7,6)])\nmesh   = SimpleMesh(points, connec)\n\n# refine three times\nref1 = refine(mesh, CatmullClark())\nref2 = refine(ref1, CatmullClark())\nref3 = refine(ref2, CatmullClark())\n\nfig = Mke.Figure(resolution = (800, 800))\nviz(fig[1,1], mesh, showfacets = true, axis = (title = \"original\",))\nviz(fig[1,2], ref1, showfacets = true, axis = (title = \"refine 1\",))\nviz(fig[2,1], ref2, showfacets = true, axis = (title = \"refine 2\",))\nviz(fig[2,2], ref3, showfacets = true, axis = (title = \"refine 3\",))\nfig","category":"page"},{"location":"angles.html#Angles","page":"Angles","title":"Angles","text":"","category":"section"},{"location":"angles.html","page":"Angles","title":"Angles","text":"∠","category":"page"},{"location":"angles.html#Meshes.∠","page":"Angles","title":"Meshes.∠","text":"∠(A, B, C)\n\nAngle ∠ABC between rays BA and BC. See https://en.wikipedia.org/wiki/Angle.\n\nUses the two-argument form of atan returning value in range [-π, π]. See https://en.wikipedia.org/wiki/Atan2.\n\nExamples\n\n∠(Point(1,0), Point(0,0), Point(0,1)) == π/2\n\n\n\n\n\n∠(u, v)\n\nAngle between vectors u and v. See https://en.wikipedia.org/wiki/Angle.\n\nUses the two-argument form of atan returning value in range [-π, π]. See https://en.wikipedia.org/wiki/Atan2.\n\nExamples\n\n∠(Vec(1,0), Vec(0,1)) == π/2\n\n\n\n\n\n","category":"function"},{"location":"contributing/devguide.html#Developer-guide","page":"Developer guide","title":"Developer guide","text":"","category":"section"},{"location":"contributing/devguide.html#Benchmarking","page":"Developer guide","title":"Benchmarking","text":"","category":"section"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"We use PkgBenchmark.jl to conduct benchmarks, coupled with BenchmarkCI.jl to automate benchmark runs with GitHub Actions on certain PRs. Currently, PRs will not run benchmarks by default. Only PRs with the label run benchmark will trigger benchmarks on push, adding a comment with the benchmark results.","category":"page"},{"location":"contributing/devguide.html#Running-benchmarks-locally","page":"Developer guide","title":"Running benchmarks locally","text":"","category":"section"},{"location":"contributing/devguide.html#With-PkgBenchmark","page":"Developer guide","title":"With PkgBenchmark","text":"","category":"section"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"To locally run benchmarks, you can use PkgBenchmark.jl with the following code:","category":"page"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"# make sure PkgBenchmark and BenchmarkTools\n# are installed globally before running it\nusing Meshes, PkgBenchmark\nbenchmarkpkg(Meshes)","category":"page"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"It will include benchmark/benchmarks.jl and look for a BenchmarkGroup variable named SUITE, that it will run for you with a nice printing.","category":"page"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"The full list of options is detailed in the PkgBenchmark documentation.","category":"page"},{"location":"contributing/devguide.html#Manually","page":"Developer guide","title":"Manually","text":"","category":"section"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"Sometimes you may prefer to run the suite manually, especially during interactive development. All you have to do is include the benchmark/benchmarks.jl file, and run the BenchmarkGroup suite:","category":"page"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"include(\"benchmark/benchmarks.jl\")\nrun(SUITE)","category":"page"},{"location":"contributing/devguide.html#Limitations","page":"Developer guide","title":"Limitations","text":"","category":"section"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"Note that because GitHub Actions may use different runners between benchmarks, you are likely to see fluctuations and performance changes that may not always be relevant. This makes it somewhat unreliable for tracking regressions.","category":"page"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"Benchmark results can be very useful for validation, for example when optimizing or modifying existing features, but you are encouraged to benchmark important changes locally.","category":"page"},{"location":"index.html#Meshes.jl","page":"Home","title":"Meshes.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Computational geometry and meshing algorithms in Julia.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage Status) (Image: Stable Documentation) (Image: Latest Documentation) (Image: License File)","category":"page"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Meshes.jl provides efficient implementations of concepts from computational geometry and finite element analysis. It promotes rigorous mathematical definitions of spatial discretizations (a.k.a. meshes) that are adequate for describing general manifolds embedded in R^n, including surfaces described with spherical coordinates, and geometries described with multiple coordinate reference systems. Our ambitious goal is to provide all the features of the CGAL project in pure Julia.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Unlike other existing efforts in the Julia ecosystem, this project is being carefully designed to facilitate the use of meshes across different scientific domains. We follow a strict set of good software engineering practices, and are quite pedantic in our test suite to make sure that all our implementations are free of bugs in both single and double floating point precision. Additionally, we guarantee type stability.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The design of this project was motivated by various issues encountered with past attempts to represent geometry, which have been originally designed for visualization purposes (e.g. GeometryTypes.jl, GeometryBasics.jl) or specifically for finite element analysis (e.g. JuAFEM.jl, MeshCore.jl). We hope to provide a smoother experience with mesh representations that are adequate for finite finite element analysis, advanced geospatial modeling and visualization, not just one domain.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Get the latest stable release with Julia's package manager:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"] add Meshes","category":"page"},{"location":"index.html#Quick-example","page":"Home","title":"Quick example","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Although we didn't have time to document the functionality of the package properly, we still would like to illustrate some important features. For more information on available functionality, please consult the Reference guide and the suite of tests in the package.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Meshes, MeshViz\nimport CairoMakie as Mke","category":"page"},{"location":"index.html#Points-and-vectors","page":"Home","title":"Points and vectors","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A Point is defined by its coordinates in a global reference system. The type of the coordinates is determined automatically based on the specified literals, or is forced to a specific type using helper constructors (e.g. Point2, Point3, Point2f, Point3f). Integer coordinates are converted to Float64 to fulfill the requirements of most geometric processing algorithms, which would be undefined in a discrete scale.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A vector Vec follows the same pattern. It can be constructed with the generic Vec constructor or with the variants Vec2 and Vec3 for double precision and Vec2f and Vec3f for single precision.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"# 2D points\nA = Point(0.0, 1.0) # double precision as expected\nB = Point(0f0, 1f0) # single precision as expected\nC = Point(0, 0) # Integer is converted to Float64 by design\nD = Point2(0, 1) # explicitly ask for double precision\nE = Point2f(0, 1) # explicitly ask for single precision\n\n# 3D points\nF = Point(1.0, 2.0, 3.0) # double precision as expected\nG = Point(1f0, 2f0, 3f0) # single precision as expected\nH = Point(1, 2, 3) # Integer is converted to Float64 by design\nI = Point3(1, 2, 3) # explicitly ask for double precision\nJ = Point3f(1, 2, 3) # explicitly ask for single precision\n\nfor P in (A,B,C,D,E,F,G,H,I,J)\n  println(\"Coordinate type: \", coordtype(P))\n  println(\"Embedding dimension: \", embeddim(P))\nend","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Points can be subtracted to produce a vector:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"B - A","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"They can't be added, but their coordinates can:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"coordinates(F) + coordinates(H)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We can add a point to a vector though, and get a new point:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"F + Vec(1, 1, 1)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"And finally, we can create points at random with:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"ps = rand(Point2, 10)","category":"page"},{"location":"index.html#Primitives","page":"Home","title":"Primitives","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Primitive geometries such as Box, Ball, Sphere, Cylinder are those geometries that can be efficiently represented in a computer without discretization. We can construct such geometries using clean syntax:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"b = Box((0.0, 0.0, 0.0), (1.0, 1.0, 1.0))\n\nviz(b)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"s = Sphere((0.0, 0.0, 0.0), 1.0)\n\nviz(s)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The parameters of these primitive geometries can be queried easily:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"extrema(b)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"centroid(s), radius(s)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"As well as their measure (e.g. area, volume) and other geometric properties:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"measure(b)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We can sample random points on primitives using different methods:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"vs = sample(s, RegularSampling(10)) # 10 points over the sphere","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"And collect the generator with:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"viz(collect(vs))","category":"page"},{"location":"index.html#Polytopes","page":"Home","title":"Polytopes","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Polytopes are geometries with \"flat\" sides. They generalize polygons and polyhedra. Most commonly used polytopes are already defined in the project, including Segment, Ngon (e.g. Triangle, Quadrangle), Tetrahedron, Pyramid and Hexahedron.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"t = Triangle((0.0, 0.0), (1.0, 0.0), (0.0, 1.0))\n\nviz(t)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Some of these geometries have additional functionality like the measure (or area):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"measure(t) == area(t) == 1/2","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Or the ability to know whether or not a point is inside:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"p = Point(0.5, 0.0)\n\np ∈ t","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For line segments, for example, we have robust intersection algorithms:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"s1 = Segment((0.0, 0.0), (1.0, 0.0))\ns2 = Segment((0.5, 0.0), (2.0, 0.0))\n\ns1 ∩ s2","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Polytopes are widely used in GIS software under names such as \"LineString\" and \"Polygon\". We provide robust implementations of these concepts, which are formally known as polygonal Chain and PolyArea.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We can compute the orientation of a chain as clockwise or counter-clockwise, can open and close the chain, create bridges between the various inner rings with the outer ring, and other useful functionality:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"p = PolyArea((0,0), (2,0), (2,2), (1,3), (0,2), (0,0))\n\nviz(p)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The orientation of the above polygonal area is counter-clockwise (CCW):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"orientation(p)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We can get the outer polygonal chain, and reverse it:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"c = chains(p)[1]\n\nreverse(c)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A closed chain (a.k.a. ring) has circular vertices:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"v = vertices(c)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This means that we can index the vertices with indices that go beyond the range 1:nvertices(c). This is very useful for writing algorithms:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"v[1:10]","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We can also compute angles of any given chain, no matter if it is open or closed:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"angles(c) * 180 / pi","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The sign of these angles is a function of the orientation:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"angles(reverse(c)) * 180 / pi","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"In case of closed chains, we can compute inner angles as well:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"innerangles(c) * 180 / pi","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"And there is a lot more functionality available like for instance determining whether or not a polygonal area or chain is simple:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"issimple(p)","category":"page"},{"location":"index.html#Meshes","page":"Home","title":"Meshes","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Efficient (lazy) mesh representations are provided, including CartesianGrid and SimpleMesh:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"g = CartesianGrid(100, 100)\n\nviz(g, showfacets = true)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"No memory is allocated:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@allocated CartesianGrid(10000, 10000, 10000)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"but we can still loop over the elements, which are quadrangles in 2D:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"collect(elements(g))","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We can construct a general unstructured mesh with a global vector of points and a collection of Connectivity that store the indices to the global vector of points:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"points = Point2[(0,0), (1,0), (0,1), (1,1), (0.25,0.5), (0.75,0.5)]\ntris  = connect.([(1,5,3), (4,6,2)], Triangle)\nquads = connect.([(1,2,6,5), (4,3,5,6)], Quadrangle)\nmesh = SimpleMesh(points, [tris; quads])","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"viz(mesh, showfacets = true)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The actual geometries of the elements are materialized in a lazy fashion like with the Cartesian grid:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"collect(elements(mesh))","category":"page"},{"location":"index.html#Mesh-data","page":"Home","title":"Mesh data","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To attach data to the geometries of a mesh, we can use the meshdata function, which combines a mesh object with a collection of Tables.jl tables. For example, it is common to attach a table vtable to the vertices and a table etable to the elements of the mesh:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"d = meshdata(mesh,\n  vtable = (temperature=rand(6), pressure=rand(6)),\n  etable = (quality=[\"A\",\"B\",\"C\",\"D\"], state=[true,false,true,false])\n)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"More generally, we can attach a table to any rank:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"0 (vertices)\n1 (segments)\n2 (triangles, quadrangles, ...)\n3 (tetrahedrons, hexahedrons, ...)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To retrieve the data table for a given rank we use the values function:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"values(d, 0)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"values(d, 2)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If we ommit the rank, the function will return the etable of the mesh:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"values(d)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"When a table is not available for a given rank, the value nothing is returned instead:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"values(d, 1) === nothing","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Finally, we can use the domain function to retrieve the underlying domain of the data, which in this case is a SimpleMesh:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"domain(d)","category":"page"},{"location":"algorithms/sampling.html#Sampling","page":"Sampling","title":"Sampling","text":"","category":"section"},{"location":"algorithms/sampling.html","page":"Sampling","title":"Sampling","text":"sample\nSamplingMethod\nDiscreteSamplingMethod\nContinuousSamplingMethod","category":"page"},{"location":"algorithms/sampling.html#StatsBase.sample","page":"Sampling","title":"StatsBase.sample","text":"sample([rng], object, method)\n\nSample elements or points from geometric object with method. Optionally, specify random number generator rng.\n\n\n\n\n\nsample([rng], object, nsamples, [weights], replace=false)\n\nGenerate nsamples samples from spatial object uniformly or using weights, with or without replacement depending on replace option.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/sampling.html#Meshes.SamplingMethod","page":"Sampling","title":"Meshes.SamplingMethod","text":"SamplingMethod\n\nA method for sampling from geometric objects.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling.html#Meshes.DiscreteSamplingMethod","page":"Sampling","title":"Meshes.DiscreteSamplingMethod","text":"DiscreteSamplingMethod\n\nA method for sampling from discrete representations of geometric objects such as meshes or collections of geometries.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling.html#Meshes.ContinuousSamplingMethod","page":"Sampling","title":"Meshes.ContinuousSamplingMethod","text":"ContinuousSamplingMethod\n\nA method for sampling from continuous representations of geometric objects. In this case, geometric objects are interpreted as a set of points in the embedding space.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling.html#Discrete-sampling","page":"Sampling","title":"Discrete sampling","text":"","category":"section"},{"location":"algorithms/sampling.html","page":"Sampling","title":"Sampling","text":"UniformSampling\nWeightedSampling\nBallSampling","category":"page"},{"location":"algorithms/sampling.html#Meshes.UniformSampling","page":"Sampling","title":"Meshes.UniformSampling","text":"UniformSampling(size, replace=false)\n\nSample elements uniformly from a given domain/data. Produce a sample of given size with or without replacement depending on the replace option.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling.html#Meshes.WeightedSampling","page":"Sampling","title":"Meshes.WeightedSampling","text":"WeightedSampling(size, [weights]; replace=false)\n\nSample elements from a given domain/data using weights. Produce a sample of given size with or without replacement depending on the replace option. By default weights are uniform.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling.html#Meshes.BallSampling","page":"Sampling","title":"Meshes.BallSampling","text":"BallSampling(radius; [options])\n\nA method for sampling isolated elements from a given domain/data according to a norm-ball of given radius.\n\nOptions\n\nmetric  - Metric for the ball (default to Euclidean())\nmaxsize - Maximum size of the resulting sample (default to none)\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling.html#Continuous-sampling","page":"Sampling","title":"Continuous sampling","text":"","category":"section"},{"location":"algorithms/sampling.html","page":"Sampling","title":"Sampling","text":"RegularSampling\nHomogeneousSampling\nMinDistanceSampling","category":"page"},{"location":"algorithms/sampling.html#Meshes.RegularSampling","page":"Sampling","title":"Meshes.RegularSampling","text":"RegularSampling(n1, n2, ..., np)\n\nGenerate samples regularly using n1 points along the first parametric dimension, n2 points along the second parametric dimension, ..., np poitns along the last parametric dimension.\n\nExamples\n\nSample sphere regularly with 360 longitudes and 180 latitudes:\n\nsample(Sphere((0,0,0), 1), RegularSampling(360, 180))\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling.html#Meshes.HomogeneousSampling","page":"Sampling","title":"Meshes.HomogeneousSampling","text":"HomogeneousSampling(size)\n\nGenerate sample of given size from geometric object according to a homogeneous density.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling.html#Meshes.MinDistanceSampling","page":"Sampling","title":"Meshes.MinDistanceSampling","text":"MinDistanceSampling(α, ρ=0.65, δ=100, metric=Euclidean())\n\nGenerate sample from geometric object such that all pairs of points are at least α units of distance away from each other. Optionally specify the relative radius ρ for the packing pattern, the oversampling factor δ and the metric.\n\nThis method is sometimes referred to as Poisson disk sampling or blue noise sampling in the computer graphics community.\n\nReferences\n\nLagae, A. & Dutré, P. 2007. A Comparison of Methods for Generating Poisson Disk Distributions\nBowers et al. 2010. Parallel Poisson disk sampling with spectrum analysis on surfaces\nMedeiros et al. 2014. Fast adaptive blue noise on polygonal surfaces\n\n\n\n\n\n","category":"type"}]
}
