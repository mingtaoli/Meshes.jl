<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Meshes.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.svg" alt="Meshes.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Meshes.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href="index.html">Home</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Quick-example"><span>Quick example</span></a></li></ul></li><li><span class="tocitem">Reference guide</span><ul><li><a class="tocitem" href="points.html">Points</a></li><li><a class="tocitem" href="vectors.html">Vectors</a></li><li><a class="tocitem" href="angles.html">Angles</a></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Geometries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="geometries/primitives.html">Primitives</a></li><li><a class="tocitem" href="geometries/polytopes.html">Polytopes</a></li></ul></li><li><a class="tocitem" href="meshes.html">Meshes</a></li><li><a class="tocitem" href="meshdata.html">Mesh data</a></li><li><a class="tocitem" href="neighborhoods.html">Neighborhoods</a></li><li><input class="collapse-toggle" id="menuitem-2-8" type="checkbox"/><label class="tocitem" for="menuitem-2-8"><span class="docs-label">Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="algorithms/sampling.html">Sampling</a></li><li><a class="tocitem" href="algorithms/partitioning.html">Partition</a></li><li><a class="tocitem" href="algorithms/discretization.html">Discretization</a></li><li><a class="tocitem" href="algorithms/refinement.html">Refinement</a></li><li><a class="tocitem" href="algorithms/smoothing.html">Smoothing</a></li><li><a class="tocitem" href="algorithms/simplification.html">Simplification</a></li><li><a class="tocitem" href="algorithms/intersection.html">Intersection</a></li><li><a class="tocitem" href="algorithms/neighborsearch.html">Neighbor search</a></li><li><a class="tocitem" href="algorithms/boundingbox.html">Bounding box</a></li><li><a class="tocitem" href="algorithms/hulls.html">Hulls</a></li></ul></li><li><a class="tocitem" href="visualization.html">Visualization</a></li><li><a class="tocitem" href="traits.html">Traits</a></li></ul></li><li><span class="tocitem">Contributing</span><ul><li><a class="tocitem" href="contributing/guidelines.html">Guidelines</a></li><li><a class="tocitem" href="contributing/devguide.html">Developer guide</a></li></ul></li><li><span class="tocitem">About</span><ul><li><a class="tocitem" href="about/license.html">License</a></li></ul></li><li><a class="tocitem" href="links.html">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="index.html">Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="index.html">Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGeometry/Meshes.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Meshes.jl"><a class="docs-heading-anchor" href="#Meshes.jl">Meshes.jl</a><a id="Meshes.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes.jl" title="Permalink"></a></h1><p><em>Computational geometry and meshing algorithms in Julia.</em></p><p><a href="https://github.com/JuliaGeometry/Meshes.jl/actions"><img src="https://img.shields.io/github/workflow/status/JuliaGeometry/Meshes.jl/CI?style=flat-square" alt="Build Status"/></a> <a href="https://codecov.io/gh/JuliaGeometry/Meshes.jl"><img src="https://img.shields.io/codecov/c/github/JuliaGeometry/Meshes.jl?style=flat-square" alt="Coverage Status"/></a> <a href="https://JuliaGeometry.github.io/Meshes.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue?style=flat-square" alt="Stable Documentation"/></a> <a href="https://JuliaGeometry.github.io/Meshes.jl/dev"><img src="https://img.shields.io/badge/docs-latest-blue?style=flat-square" alt="Latest Documentation"/></a> <a href="https://github.com/JuliaGeometry/Meshes.jl/blob/master/LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue?style=flat-square" alt="License File"/></a></p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p><a href="https://github.com/JuliaGeometry/Meshes.jl">Meshes.jl</a> provides efficient implementations of concepts from computational geometry and finite element analysis. It promotes rigorous mathematical definitions of spatial discretizations (a.k.a. meshes) that are adequate for describing general manifolds embedded in <span>$\R^n$</span>, including surfaces described with spherical coordinates, and geometries described with multiple coordinate reference systems. Our ambitious goal is to provide all the features of the <a href="https://www.cgal.org">CGAL</a> project in pure Julia.</p><p>Unlike other existing efforts in the Julia ecosystem, this project is being carefully designed to facilitate the use of <em>meshes across different scientific domains</em>. We follow a strict set of good software engineering practices, and are quite pedantic in our test suite to make sure that all our implementations are free of bugs in both single and double floating point precision. Additionally, we guarantee type stability.</p><p>The design of this project was motivated by various issues encountered with past attempts to represent geometry, which have been originally designed for visualization purposes (e.g. <a href="https://github.com/JuliaGeometry/GeometryTypes.jl">GeometryTypes.jl</a>, <a href="https://github.com/JuliaGeometry/GeometryBasics.jl">GeometryBasics.jl</a>) or specifically for finite element analysis (e.g. <a href="https://kristofferc.github.io/JuAFEM.jl/dev/manual/grid">JuAFEM.jl</a>, <a href="https://github.com/PetrKryslUCSD/MeshCore.jl">MeshCore.jl</a>). We hope to provide a smoother experience with mesh representations that are adequate for finite finite element analysis, advanced geospatial modeling <em>and</em> visualization, not just one domain.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>Get the latest stable release with Julia&#39;s package manager:</p><pre><code class="language-julia hljs">] add Meshes</code></pre><h2 id="Quick-example"><a class="docs-heading-anchor" href="#Quick-example">Quick example</a><a id="Quick-example-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-example" title="Permalink"></a></h2><p>Although we didn&#39;t have time to document the functionality of the package properly, we still would like to illustrate some important features. For more information on available functionality, please consult the <a href="points.html">Reference guide</a> and the <a href="https://github.com/JuliaGeometry/Meshes.jl/tree/master/test">suite of tests</a> in the package.</p><pre><code class="language-julia hljs">using Meshes, MeshViz
import WGLMakie as Mke</code></pre><h3 id="Points-and-vectors"><a class="docs-heading-anchor" href="#Points-and-vectors">Points and vectors</a><a id="Points-and-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Points-and-vectors" title="Permalink"></a></h3><p>A <a href="points.html#Meshes.Point"><code>Point</code></a> is defined by its coordinates in a global reference system. The type of the coordinates is determined automatically based on the specified literals, or is forced to a specific type using helper constructors (e.g. <code>Point2</code>, <code>Point3</code>, <code>Point2f</code>, <code>Point3f</code>). <code>Integer</code> coordinates are converted to <code>Float64</code> to fulfill the requirements of most geometric processing algorithms, which would be undefined in a discrete scale.</p><p>A vector <a href="vectors.html#Meshes.Vec"><code>Vec</code></a> follows the same pattern. It can be constructed with the generic <code>Vec</code> constructor or with the variants <code>Vec2</code> and <code>Vec3</code> for double precision and <code>Vec2f</code> and <code>Vec3f</code> for single precision.</p><pre><code class="language-julia hljs"># 2D points
A = Point(0.0, 1.0) # double precision as expected
B = Point(0f0, 1f0) # single precision as expected
C = Point(0, 0) # Integer is converted to Float64 by design
D = Point2(0, 1) # explicitly ask for double precision
E = Point2f(0, 1) # explicitly ask for single precision

# 3D points
F = Point(1.0, 2.0, 3.0) # double precision as expected
G = Point(1f0, 2f0, 3f0) # single precision as expected
H = Point(1, 2, 3) # Integer is converted to Float64 by design
I = Point3(1, 2, 3) # explicitly ask for double precision
J = Point3f(1, 2, 3) # explicitly ask for single precision

for P in (A,B,C,D,E,F,G,H,I,J)
  println(&quot;Coordinate type: &quot;, coordtype(P))
  println(&quot;Embedding dimension: &quot;, embeddim(P))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Coordinate type: Float64
Embedding dimension: 2
Coordinate type: Float32
Embedding dimension: 2
Coordinate type: Float64
Embedding dimension: 2
Coordinate type: Float64
Embedding dimension: 2
Coordinate type: Float32
Embedding dimension: 2
Coordinate type: Float64
Embedding dimension: 3
Coordinate type: Float32
Embedding dimension: 3
Coordinate type: Float64
Embedding dimension: 3
Coordinate type: Float64
Embedding dimension: 3
Coordinate type: Float32
Embedding dimension: 3</code></pre><p>Points can be subtracted to produce a vector:</p><pre><code class="language-julia hljs">B - A</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element StaticArrays.SVector{2, Float64} with indices SOneTo(2):
 0.0
 0.0</code></pre><p>They can&#39;t be added, but their coordinates can:</p><pre><code class="language-julia hljs">coordinates(F) + coordinates(H)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):
 2.0
 4.0
 6.0</code></pre><p>We can add a point to a vector though, and get a new point:</p><pre><code class="language-julia hljs">F + Vec(1, 1, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Point(2.0, 3.0, 4.0)</code></pre><p>And finally, we can create points at random with:</p><pre><code class="language-julia hljs">ps = rand(Point2, 10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{Point2}:
 Point(0.7460628081563685, 0.9469203997623081)
 Point(0.6766726815568567, 0.24472683652542515)
 Point(0.2280701232378517, 0.3223157270364234)
 Point(0.49218316467068024, 0.9265937915201381)
 Point(0.041859763030895336, 0.041091640214683034)
 Point(0.14303639009229674, 0.1003472335063984)
 Point(0.03026944116441399, 0.7192070901812311)
 Point(0.4294377784904382, 0.7797714597663075)
 Point(0.3423142494671704, 0.6837185536937666)
 Point(0.0685582943145635, 0.7391692791447197)</code></pre><h3 id="Primitives"><a class="docs-heading-anchor" href="#Primitives">Primitives</a><a id="Primitives-1"></a><a class="docs-heading-anchor-permalink" href="#Primitives" title="Permalink"></a></h3><p>Primitive geometries such as <a href="geometries/primitives.html#Meshes.Box"><code>Box</code></a>, <a href="geometries/primitives.html#Meshes.Ball"><code>Ball</code></a>, <a href="geometries/primitives.html#Meshes.Sphere"><code>Sphere</code></a>, <a href="geometries/primitives.html#Meshes.Cylinder"><code>Cylinder</code></a> are those geometries that can be efficiently represented in a computer without discretization. We can construct such geometries using clean syntax:</p><pre><code class="language-julia hljs">b = Box((0.0, 0.0, 0.0), (1.0, 1.0, 1.0))

viz(b)</code></pre><div data-jscall-id="38"><script data-jscall-id="39" type="text/javascript">
    function register_resize_handler(remote_origin) {
        function resize_callback(event) {
            if (event.origin !== remote_origin) {
                return;
            }
            const uuid = event.data[0];
            const width = event.data[1];
            const height = event.data[2];
            const iframe = document.getElementById('dd13d04a-2a20-4bc6-89f5-36de146c9625');
            if (iframe) {
                iframe.style.width = width + "px";
                iframe.style.height = height + "px";
            }
        }
        if (window.addEventListener) {
            window.addEventListener("message", resize_callback, false);
        } else if (window.attachEvent) {
            window.attachEvent("onmessage", resize_callback);
        }
    }
    register_resize_handler('http://127.0.0.1:9284')

</script><iframe scrolling="no" id="dd13d04a-2a20-4bc6-89f5-36de146c9625" data-jscall-id="37" src="http://127.0.0.1:9284/dd13d04a-2a20-4bc6-89f5-36de146c9625" style="position: relative; display: block; width: 100%; height: 100%; padding: 0; overflow: hidden; border: none"></iframe></div>
<pre><code class="language-julia hljs">s = Sphere((0.0, 0.0, 0.0), 1.0)

viz(s)</code></pre><div data-jscall-id="41"><script data-jscall-id="42" type="text/javascript">
    function register_resize_handler(remote_origin) {
        function resize_callback(event) {
            if (event.origin !== remote_origin) {
                return;
            }
            const uuid = event.data[0];
            const width = event.data[1];
            const height = event.data[2];
            const iframe = document.getElementById('eced6a1e-fe11-450f-9b9f-38f07da9e817');
            if (iframe) {
                iframe.style.width = width + "px";
                iframe.style.height = height + "px";
            }
        }
        if (window.addEventListener) {
            window.addEventListener("message", resize_callback, false);
        } else if (window.attachEvent) {
            window.attachEvent("onmessage", resize_callback);
        }
    }
    register_resize_handler('http://127.0.0.1:9284')

</script><iframe scrolling="no" id="eced6a1e-fe11-450f-9b9f-38f07da9e817" data-jscall-id="40" src="http://127.0.0.1:9284/eced6a1e-fe11-450f-9b9f-38f07da9e817" style="position: relative; display: block; width: 100%; height: 100%; padding: 0; overflow: hidden; border: none"></iframe></div>
<p>The parameters of these primitive geometries can be queried easily:</p><pre><code class="language-julia hljs">extrema(b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Point(0.0, 0.0, 0.0), Point(1.0, 1.0, 1.0))</code></pre><pre><code class="language-julia hljs">centroid(s), radius(s)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Point(0.0, 0.0, 0.0), 1.0)</code></pre><p>As well as their measure (e.g. area, volume) and other geometric properties:</p><pre><code class="language-julia hljs">measure(b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0</code></pre><p>We can sample random points on primitives using different methods:</p><pre><code class="language-julia hljs">vs = sample(s, RegularSampling(10)) # 10 points over the sphere</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">IterTools.IVec{Base.Generator{Base.Iterators.ProductIterator{Tuple{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}}, Meshes.var&quot;#183#185&quot;{Meshes.var&quot;#r⃗#184&quot;{Float64, Float64}, Point3}}}(Base.Generator{Base.Iterators.ProductIterator{Tuple{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}}, Meshes.var&quot;#183#185&quot;{Meshes.var&quot;#r⃗#184&quot;{Float64, Float64}, Point3}}(Meshes.var&quot;#183#185&quot;{Meshes.var&quot;#r⃗#184&quot;{Float64, Float64}, Point3}(Meshes.var&quot;#r⃗#184&quot;{Float64, Float64}(1.0), Point(0.0, 0.0, 0.0)), Base.Iterators.ProductIterator{Tuple{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}}((0.28559933214452665:0.28559933214452665:2.8559933214452666, 0.0:0.6283185307179586:5.654866776461628))))</code></pre><p>And collect the generator with:</p><pre><code class="language-julia hljs">viz(collect(vs))</code></pre><div data-jscall-id="44"><script data-jscall-id="45" type="text/javascript">
    function register_resize_handler(remote_origin) {
        function resize_callback(event) {
            if (event.origin !== remote_origin) {
                return;
            }
            const uuid = event.data[0];
            const width = event.data[1];
            const height = event.data[2];
            const iframe = document.getElementById('fe87868c-cca7-450b-b2cd-ad821be6fc36');
            if (iframe) {
                iframe.style.width = width + "px";
                iframe.style.height = height + "px";
            }
        }
        if (window.addEventListener) {
            window.addEventListener("message", resize_callback, false);
        } else if (window.attachEvent) {
            window.attachEvent("onmessage", resize_callback);
        }
    }
    register_resize_handler('http://127.0.0.1:9284')

</script><iframe scrolling="no" id="fe87868c-cca7-450b-b2cd-ad821be6fc36" data-jscall-id="43" src="http://127.0.0.1:9284/fe87868c-cca7-450b-b2cd-ad821be6fc36" style="position: relative; display: block; width: 100%; height: 100%; padding: 0; overflow: hidden; border: none"></iframe></div>
<h3 id="Polytopes"><a class="docs-heading-anchor" href="#Polytopes">Polytopes</a><a id="Polytopes-1"></a><a class="docs-heading-anchor-permalink" href="#Polytopes" title="Permalink"></a></h3><p>Polytopes are geometries with &quot;flat&quot; sides. They generalize polygons and polyhedra. Most commonly used polytopes are already defined in the project, including <a href="geometries/polytopes.html#Meshes.Segment"><code>Segment</code></a>, <a href="geometries/polytopes.html#Meshes.Ngon"><code>Ngon</code></a> (e.g. Triangle, Quadrangle), <a href="geometries/polytopes.html#Meshes.Tetrahedron"><code>Tetrahedron</code></a>, <a href="geometries/polytopes.html#Meshes.Pyramid"><code>Pyramid</code></a> and <a href="geometries/polytopes.html#Meshes.Hexahedron"><code>Hexahedron</code></a>.</p><pre><code class="language-julia hljs">t = Triangle((0.0, 0.0), (1.0, 0.0), (0.0, 1.0))

viz(t)</code></pre><div data-jscall-id="47"><script data-jscall-id="48" type="text/javascript">
    function register_resize_handler(remote_origin) {
        function resize_callback(event) {
            if (event.origin !== remote_origin) {
                return;
            }
            const uuid = event.data[0];
            const width = event.data[1];
            const height = event.data[2];
            const iframe = document.getElementById('65eaca1d-f182-49f3-816b-34e50ffe7bb9');
            if (iframe) {
                iframe.style.width = width + "px";
                iframe.style.height = height + "px";
            }
        }
        if (window.addEventListener) {
            window.addEventListener("message", resize_callback, false);
        } else if (window.attachEvent) {
            window.attachEvent("onmessage", resize_callback);
        }
    }
    register_resize_handler('http://127.0.0.1:9284')

</script><iframe scrolling="no" id="65eaca1d-f182-49f3-816b-34e50ffe7bb9" data-jscall-id="46" src="http://127.0.0.1:9284/65eaca1d-f182-49f3-816b-34e50ffe7bb9" style="position: relative; display: block; width: 100%; height: 100%; padding: 0; overflow: hidden; border: none"></iframe></div>
<p>Some of these geometries have additional functionality like the measure (or area):</p><pre><code class="language-julia hljs">measure(t) == area(t) == 1/2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Or the ability to know whether or not a point is inside:</p><pre><code class="language-julia hljs">p = Point(0.5, 0.0)

p ∈ t</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>For line segments, for example, we have robust intersection algorithms:</p><pre><code class="language-julia hljs">s1 = Segment((0.0, 0.0), (1.0, 0.0))
s2 = Segment((0.5, 0.0), (2.0, 0.0))

s1 ∩ s2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Segment{2,Float64}
  └─Point(0.5, 0.0)
  └─Point(1.0, 0.0)</code></pre><p>Polytopes are widely used in GIS software under names such as &quot;LineString&quot; and &quot;Polygon&quot;. We provide robust implementations of these concepts, which are formally known as polygonal <a href="geometries/polytopes.html#Meshes.Chain"><code>Chain</code></a> and <a href="geometries/polytopes.html#Meshes.PolyArea"><code>PolyArea</code></a>.</p><p>We can compute the orientation of a chain as clockwise or counter-clockwise, can open and close the chain, create bridges between the various inner rings with the outer ring, and other useful functionality:</p><pre><code class="language-julia hljs">p = PolyArea((0,0), (2,0), (2,2), (1,3), (0,2), (0,0))

viz(p)</code></pre><div data-jscall-id="50"><script data-jscall-id="51" type="text/javascript">
    function register_resize_handler(remote_origin) {
        function resize_callback(event) {
            if (event.origin !== remote_origin) {
                return;
            }
            const uuid = event.data[0];
            const width = event.data[1];
            const height = event.data[2];
            const iframe = document.getElementById('352c4d3a-1b89-448c-a01c-084c21a41c8a');
            if (iframe) {
                iframe.style.width = width + "px";
                iframe.style.height = height + "px";
            }
        }
        if (window.addEventListener) {
            window.addEventListener("message", resize_callback, false);
        } else if (window.attachEvent) {
            window.attachEvent("onmessage", resize_callback);
        }
    }
    register_resize_handler('http://127.0.0.1:9284')

</script><iframe scrolling="no" id="352c4d3a-1b89-448c-a01c-084c21a41c8a" data-jscall-id="49" src="http://127.0.0.1:9284/352c4d3a-1b89-448c-a01c-084c21a41c8a" style="position: relative; display: block; width: 100%; height: 100%; padding: 0; overflow: hidden; border: none"></iframe></div>
<p>The orientation of the above polygonal area is counter-clockwise (CCW):</p><pre><code class="language-julia hljs">orientation(p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">:CCW</code></pre><p>We can get the outer polygonal chain, and reverse it:</p><pre><code class="language-julia hljs">c = chains(p)[1]

reverse(c)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-Chain{2,Float64}
  └─Point(0.0, 0.0)
  └─Point(0.0, 2.0)
  └─Point(1.0, 3.0)
  └─Point(2.0, 2.0)
  └─Point(2.0, 0.0)
  └─Point(0.0, 0.0)</code></pre><p>A closed chain (a.k.a. ring) has circular vertices:</p><pre><code class="language-julia hljs">v = vertices(c)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element CircularVector(view(::Vector{Point2}, 1:5)):
 Point(0.0, 0.0)
 Point(2.0, 0.0)
 Point(2.0, 2.0)
 Point(1.0, 3.0)
 Point(0.0, 2.0)</code></pre><p>This means that we can index the vertices with indices that go beyond the range <code>1:nvertices(c)</code>. This is very useful for writing algorithms:</p><pre><code class="language-julia hljs">v[1:10]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element CircularVector(::Vector{Point2}):
 Point(0.0, 0.0)
 Point(2.0, 0.0)
 Point(2.0, 2.0)
 Point(1.0, 3.0)
 Point(0.0, 2.0)
 Point(0.0, 0.0)
 Point(2.0, 0.0)
 Point(2.0, 2.0)
 Point(1.0, 3.0)
 Point(0.0, 2.0)</code></pre><p>We can also compute angles of any given chain, no matter if it is open or closed:</p><pre><code class="language-julia hljs">angles(c) * 180 / pi</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
  -90.0
  -90.0
 -135.0
  -90.0
 -135.0</code></pre><p>The sign of these angles is a function of the orientation:</p><pre><code class="language-julia hljs">angles(reverse(c)) * 180 / pi</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
  90.0
 135.0
  90.0
 135.0
  90.0</code></pre><p>In case of closed chains, we can compute inner angles as well:</p><pre><code class="language-julia hljs">innerangles(c) * 180 / pi</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
  90.0
  90.0
 135.0
  90.0
 135.0</code></pre><p>And there is a lot more functionality available like for instance determining whether or not a polygonal area or chain is simple:</p><pre><code class="language-julia hljs">issimple(p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h3 id="Meshes"><a class="docs-heading-anchor" href="#Meshes">Meshes</a><a id="Meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes" title="Permalink"></a></h3><p>Efficient (lazy) mesh representations are provided, including <a href="meshes.html#Meshes.CartesianGrid"><code>CartesianGrid</code></a> and <a href="meshes.html#Meshes.SimpleMesh"><code>SimpleMesh</code></a>:</p><pre><code class="language-julia hljs">g = CartesianGrid(100, 100)

viz(g, showfacets = true)</code></pre><div data-jscall-id="53"><script data-jscall-id="54" type="text/javascript">
    function register_resize_handler(remote_origin) {
        function resize_callback(event) {
            if (event.origin !== remote_origin) {
                return;
            }
            const uuid = event.data[0];
            const width = event.data[1];
            const height = event.data[2];
            const iframe = document.getElementById('e5c1d8d8-b075-4368-859e-6c258eb7093a');
            if (iframe) {
                iframe.style.width = width + "px";
                iframe.style.height = height + "px";
            }
        }
        if (window.addEventListener) {
            window.addEventListener("message", resize_callback, false);
        } else if (window.attachEvent) {
            window.attachEvent("onmessage", resize_callback);
        }
    }
    register_resize_handler('http://127.0.0.1:9284')

</script><iframe scrolling="no" id="e5c1d8d8-b075-4368-859e-6c258eb7093a" data-jscall-id="52" src="http://127.0.0.1:9284/e5c1d8d8-b075-4368-859e-6c258eb7093a" style="position: relative; display: block; width: 100%; height: 100%; padding: 0; overflow: hidden; border: none"></iframe></div>
<p>No memory is allocated:</p><pre><code class="language-julia hljs">@allocated CartesianGrid(10000, 10000, 10000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0</code></pre><p>but we can still loop over the elements, which are quadrangles in 2D:</p><pre><code class="language-julia hljs">collect(elements(g))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000-element Vector{Quadrangle{2, Float64, Vector{Point2}}}:
 Quadrangle(Point(0.0, 0.0), Point(1.0, 0.0), Point(1.0, 1.0), Point(0.0, 1.0))
 Quadrangle(Point(1.0, 0.0), Point(2.0, 0.0), Point(2.0, 1.0), Point(1.0, 1.0))
 Quadrangle(Point(2.0, 0.0), Point(3.0, 0.0), Point(3.0, 1.0), Point(2.0, 1.0))
 Quadrangle(Point(3.0, 0.0), Point(4.0, 0.0), Point(4.0, 1.0), Point(3.0, 1.0))
 Quadrangle(Point(4.0, 0.0), Point(5.0, 0.0), Point(5.0, 1.0), Point(4.0, 1.0))
 Quadrangle(Point(5.0, 0.0), Point(6.0, 0.0), Point(6.0, 1.0), Point(5.0, 1.0))
 Quadrangle(Point(6.0, 0.0), Point(7.0, 0.0), Point(7.0, 1.0), Point(6.0, 1.0))
 Quadrangle(Point(7.0, 0.0), Point(8.0, 0.0), Point(8.0, 1.0), Point(7.0, 1.0))
 Quadrangle(Point(8.0, 0.0), Point(9.0, 0.0), Point(9.0, 1.0), Point(8.0, 1.0))
 Quadrangle(Point(9.0, 0.0), Point(10.0, 0.0), Point(10.0, 1.0), Point(9.0, 1.0))
 ⋮
 Quadrangle(Point(91.0, 99.0), Point(92.0, 99.0), Point(92.0, 100.0), Point(91.0, 100.0))
 Quadrangle(Point(92.0, 99.0), Point(93.0, 99.0), Point(93.0, 100.0), Point(92.0, 100.0))
 Quadrangle(Point(93.0, 99.0), Point(94.0, 99.0), Point(94.0, 100.0), Point(93.0, 100.0))
 Quadrangle(Point(94.0, 99.0), Point(95.0, 99.0), Point(95.0, 100.0), Point(94.0, 100.0))
 Quadrangle(Point(95.0, 99.0), Point(96.0, 99.0), Point(96.0, 100.0), Point(95.0, 100.0))
 Quadrangle(Point(96.0, 99.0), Point(97.0, 99.0), Point(97.0, 100.0), Point(96.0, 100.0))
 Quadrangle(Point(97.0, 99.0), Point(98.0, 99.0), Point(98.0, 100.0), Point(97.0, 100.0))
 Quadrangle(Point(98.0, 99.0), Point(99.0, 99.0), Point(99.0, 100.0), Point(98.0, 100.0))
 Quadrangle(Point(99.0, 99.0), Point(100.0, 99.0), Point(100.0, 100.0), Point(99.0, 100.0))</code></pre><p>We can construct a general unstructured mesh with a global vector of points and a collection of <a href="meshes.html#Meshes.Connectivity"><code>Connectivity</code></a> that store the indices to the global vector of points:</p><pre><code class="language-julia hljs">points = Point2[(0,0), (1,0), (0,1), (1,1), (0.25,0.5), (0.75,0.5)]
tris  = connect.([(1,5,3), (4,6,2)], Triangle)
quads = connect.([(1,2,6,5), (4,3,5,6)], Quadrangle)
mesh = SimpleMesh(points, [tris; quads])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4 SimpleMesh{2,Float64}
  6 vertices
    └─Point(0.0, 0.0)
    └─Point(1.0, 0.0)
    └─Point(0.0, 1.0)
    └─Point(1.0, 1.0)
    └─Point(0.25, 0.5)
    └─Point(0.75, 0.5)
  4 elements
    └─Triangle(1, 5, 3)
    └─Triangle(4, 6, 2)
    └─Quadrangle(1, 2, 6, 5)
    └─Quadrangle(4, 3, 5, 6)</code></pre><pre><code class="language-julia hljs">viz(mesh, showfacets = true)</code></pre><div data-jscall-id="56"><script data-jscall-id="57" type="text/javascript">
    function register_resize_handler(remote_origin) {
        function resize_callback(event) {
            if (event.origin !== remote_origin) {
                return;
            }
            const uuid = event.data[0];
            const width = event.data[1];
            const height = event.data[2];
            const iframe = document.getElementById('32c563eb-b1cc-4882-84aa-850402ba2ccb');
            if (iframe) {
                iframe.style.width = width + "px";
                iframe.style.height = height + "px";
            }
        }
        if (window.addEventListener) {
            window.addEventListener("message", resize_callback, false);
        } else if (window.attachEvent) {
            window.attachEvent("onmessage", resize_callback);
        }
    }
    register_resize_handler('http://127.0.0.1:9284')

</script><iframe scrolling="no" id="32c563eb-b1cc-4882-84aa-850402ba2ccb" data-jscall-id="55" src="http://127.0.0.1:9284/32c563eb-b1cc-4882-84aa-850402ba2ccb" style="position: relative; display: block; width: 100%; height: 100%; padding: 0; overflow: hidden; border: none"></iframe></div>
<p>The actual geometries of the elements are materialized in a lazy fashion like with the Cartesian grid:</p><pre><code class="language-julia hljs">collect(elements(mesh))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Ngon{N, 2, Float64, V} where {N, V&lt;:AbstractVector{Point2}}}:
 Triangle(Point(0.0, 0.0), Point(0.25, 0.5), Point(0.0, 1.0))
 Triangle(Point(1.0, 1.0), Point(0.75, 0.5), Point(1.0, 0.0))
 Quadrangle(Point(0.0, 0.0), Point(1.0, 0.0), Point(0.75, 0.5), Point(0.25, 0.5))
 Quadrangle(Point(1.0, 1.0), Point(0.0, 1.0), Point(0.25, 0.5), Point(0.75, 0.5))</code></pre><h3 id="Mesh-data"><a class="docs-heading-anchor" href="#Mesh-data">Mesh data</a><a id="Mesh-data-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-data" title="Permalink"></a></h3><p>To attach data to the geometries of a mesh, we can use the <a href="meshdata.html#Meshes.meshdata"><code>meshdata</code></a> function, which combines a mesh object with a collection of Tables.jl tables. For example, it is common to attach a table <code>vtable</code> to the vertices and a table <code>etable</code> to the elements of the mesh:</p><pre><code class="language-julia hljs">d = meshdata(mesh,
  vtable = (temperature=rand(6), pressure=rand(6)),
  etable = (quality=[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;], state=[true,false,true,false])
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4 MeshData{2,Float64}
  variables (rank 0)
    └─pressure (Float64)
    └─temperature (Float64)
  variables (rank 2)
    └─quality (String)
    └─state (Bool)
  domain: 4 SimpleMesh{2,Float64}</code></pre><p>More generally, we can attach a table to any rank:</p><ul><li>0 (vertices)</li><li>1 (segments)</li><li>2 (triangles, quadrangles, ...)</li><li>3 (tetrahedrons, hexahedrons, ...)</li></ul><p>To retrieve the data table for a given rank we use the <code>values</code> function:</p><pre><code class="language-julia hljs">values(d, 0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(temperature = [0.904665525583525, 0.32335628332639965, 0.6176221293752532, 0.03459887838195175, 0.6137968752090237, 0.38913832615895294], pressure = [0.7285989955956335, 0.6289699821792216, 0.7378085906161613, 0.8953204825526551, 0.04509308253253608, 0.8381042566804968])</code></pre><pre><code class="language-julia hljs">values(d, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(quality = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;], state = Bool[1, 0, 1, 0])</code></pre><p>If we ommit the rank, the function will return the <code>etable</code> of the mesh:</p><pre><code class="language-julia hljs">values(d)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(quality = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;], state = Bool[1, 0, 1, 0])</code></pre><p>When a table is not available for a given rank, the value <code>nothing</code> is returned instead:</p><pre><code class="language-julia hljs">values(d, 1) === nothing</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Finally, we can use the <code>domain</code> function to retrieve the underlying domain of the data, which in this case is a <code>SimpleMesh</code>:</p><pre><code class="language-julia hljs">domain(d)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4 SimpleMesh{2,Float64}
  6 vertices
    └─Point(0.0, 0.0)
    └─Point(1.0, 0.0)
    └─Point(0.0, 1.0)
    └─Point(1.0, 1.0)
    └─Point(0.25, 0.5)
    └─Point(0.75, 0.5)
  4 elements
    └─Triangle(1, 5, 3)
    └─Triangle(4, 6, 2)
    └─Quadrangle(1, 2, 6, 5)
    └─Quadrangle(4, 3, 5, 6)</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="points.html">Points »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Monday 6 June 2022 11:05">Monday 6 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
